/***************************************************************************
                          arnSAParametric.cpp  -  description
                             -------------------
    begin                : dom mar 9 2003
    copyright            : (C) 2003 by fabio giovagnini
    email                : fabio.giovagnini@aurion-tech.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "arnSAParametric.h"
#ifdef WIN32
#include "winComPort.h"
#else
#include "arnComPort.h"
#endif

#define __UI_OUTPUT(arg...) do {QString uioutbff; \
    uioutbff.sprintf(arg); \
    if (this->outDisplay){ this->outDisplay->showMessage(uioutbff);}\
    } while (0)
#define __PROCESS() do {if (appl) {appl->processEvents();}} while (0)

//#define __CNS_OUT(arg...) do {strcat(uioutbff,"\r\n"); fprintf(stderr,arg); fflush(stdout);} while (0)
//#define __UI_OUTPUT(arg...) do {char uioutbff[1024]; 
//    sprintf(uioutbff,arg); 
//    if (this->outDisplay){ this->outDisplay->message(uioutbff);this->outDisplay->repaint();}
//    __CNS_OUT(uioutbff); 
//    } while (0)


#define EP_NONE_EP ((unsigned char) 0x00)
#define ECU_SEARCH_PC ((unsigned char)0x01)
#define PC_DELEXTFLASH_ECU ((unsigned char)0x02)
#define ECU_DELInPROG_PC ((unsigned char)0x03)
#define ECU_DELOK_PC ((unsigned char)0x04)
#define ECU_DELNOT_PC ((unsigned char)0x05)
#define PC_GODLD_ECU ((unsigned char)0x06)
#define PC_EXIT_ECU ((unsigned char)0x07)
#define PC_ERCNT_ECU ((unsigned char)0x08)


/* e' la dimensione del buffer che contiene un mappa
 in formato srecord quando vogliamo programmare anche una mappa
*/
#define PBUFF_SIZE   0x100000

/* Il massimo numero di quanti di programma : cioe' settori di spazio di indirizzamento non attigui.
 es : 0x00000000 / 0x0001FFFF un pezzo di codice
      0x00400000 / 0x00420000 un altro pezoo di codice
 */
#define MAX_UP_QUANTUM_NUMBER   8

/* il programma usato e': wd3048d1 */
const char* H83048bootprogram[] = {
"S00B000077696E643330343873",
"S214FFF3001B971B87FEFF3EC03EC13EC8FEFC3EC9A4",
"S214FFF310FE1E3ECDFEBF3ED12E5FCEF03E5F2EECF4",
"S214FFF320CE6F3EEC2EEDCE6F3EED2EEECE033EEED6",
"S214FFF3307FEF72502EF3EEF13EF3FEFF3ED83EDB3C",
"S214FFF34018EE3EB82EBACE303EBAFE0C3EB9FE01DF",
"S214FFF3505C00065418EE6AAE00FFFC517A0600FF0A",
"S214FFF360FC515C0005C86A2E00FFFC51AE0246DE6B",
"S214FFF37018EE68FE687EAE0244141AE6687E18DD54",
"S214FFF38078606AAD00FFFC400A0E68FE40E618EEA5",
"S214FFF39068FE687EAE4044141AE6687E18DD786024",
"S214FFF3A06AAD00FFFC000A0E68FE40E618EE68FE37",
"S214FFF3B0687EAE105840010CFEAA6AAE00020555E4",
"S214FFF3C0FE556AAE000202AAFE806AAE000205552E",
"S214FFF3D0FEAA6AAE00020555FE556AAE000202AAF4",
"S214FFF3E01AE6687E0D6E19667A1600020000FD307A",
"S214FFF3F068ED1AE6687E0D6E19667A160002000042",
"S214FFF400686D6AAD00FFFC49737D47024028FE0326",
"S214FFF4105C000594687E5C00058E18EE6AAE00FF01",
"S214FFF420FC517A0600FFFC515C0005026A2E00FFC5",
"S214FFF430FC49735E47BC1AE6687E0D6E19667A163F",
"S214FFF44000020000686D6AAD00FFFC49737D460A46",
"S214FFF45018EE6AAE00FFFC504008FE016AAE00FFE1",
"S214FFF460FC500CEE472AFE045C00053C687E5C0000",
"S214FFF470053618EE6AAE00FFFC517A0600FFFC5117",
"S214FFF4805C0004AA6A2E00FFFC51AE0846D8402A4C",
"S214FFF490FE055C000512687E5C00050C18EE6AAE81",
"S214FFF4A000FFFC517A0600FFFC515C0004806A2EC8",
"S214FFF4B000FFFC51AE0746D840FE687E0A0E68FE87",
"S214FFF4C05800FEECFE045C0004DE18EE6AAE00FF99",
"S214FFF4D0FC517A0600FFFC515C0004526A2E00FFC6",
"S214FFF4E0FC51AE0646DE7F40706018EE68FE687E12",
"S214FFF4F0AE04440800000A0E68FE40F2FEFF3E42DD",
"S214FFF5003E43FE016AAE00FFFC4218EE68FE687ED0",
"S214FFF510AE0244301AE62EBC7A4600000038470694",
"S214FFF5202EBCEEC73EBC7EBC736047E81AE6687E1C",
"S214FFF5302DBD78606AAD00FFFC007FBC72600A0ECE",
"S214FFF54068FE40CA6A2E00FFFC00AE45460458001F",
"S214FFF5500364AE50470CFE426AAE00FFFC00580044",
"S214FFF56003546A2E00FFFC016AAE00FFFC487EBC17",
"S214FFF5707370460240F8FE4B3EBB7FBC727018EEBF",
"S214FFF58068FE687E6A2D00FFFC481CDE44661AE6AD",
"S214FFF59001006BA600FFFC4C1AE62EBC7A46000064",
"S214FFF5A0003847062EBCEEC73EBC01006B2600FFA8",
"S214FFF5B0FC4C0B7601006BA600FFFC4C7EBC736018",
"S214FFF5C046087A260000FFFF45CE7A260000FFFF9A",
"S214FFF5D0460AFE486AAE00FFFC0040181AE6687E40",
"S214FFF5E02DBD78606AAD00FFFC027FBC72600A0E1C",
"S214FFF5F068FE408E18EE6AAE00FFFC4A68FE1AE60A",
"S214FFF6006A2E00FFFC480B061AD5687D1FD64F22D0",
"S214FFF6101AE60CDE78606A2D00FFFC006A2E00FFFB",
"S214FFF620FC4A08DE6AAE00FFFC4A687E0A0E68FEE9",
"S214FFF63040CC1AE60CDE78606A2D00FFFC006A2ECE",
"S214FFF64000FFFC4A1CED470CFE436AAE00FFFC00C1",
"S214FFF650580002626A2E00FFFC04FD0810361A0DE1",
"S214FFF66046FA6A2D00FFFC050AD66A2D00FFFC034A",
"S214FFF6700D5D19550AD61AD56A2D00FFFC02FC1837",
"S214FFF68010351A0C46FA0AD601006BA600FFFC449A",
"S214FFF69018EE68FE1AE66A2E00FFFC481B961B064D",
"S214FFF6A01AD5687D1FD658F001EC01006B2600FFC7",
"S214FFF6B0FC447A2600020000584000C01AE60CDE22",
"S214FFF6C001006B2500FFFC440AD61AD5687D7850EA",
"S214FFF6D06A2C00FFFC0668EC7906A5786B86FFA807",
"S214FFF6E07F40700018EE6EFE00016E7E0001AE0ACF",
"S214FFF6F0440A00000A0E6EFE000140EE7F407200D4",
"S214FFF7007906A5006B86FFA87F4070206EFE00017D",
"S214FFF7106E7E0001AE03440A00000A0E6EFE000174",
"S214FFF72040EE01006B2600FFFC44686D1AE6687E1B",
"S214FFF73078606A2500FFFC066AAD00FFFC491CD511",
"S214FFF74047147F4072206A2E00FFFC420A0E6AAE04",
"S214FFF75000FFFC4240024006AE285850FF7A6A2E51",
"S214FFF76000FFFC42AE28450CFE4F6AAE00FFFC00D1",
"S214FFF770580001227F4072205800011018EE6EFEDE",
"S214FFF78000011AE601006FF6000201006B2600FF7B",
"S214FFF790FC44FD1411361A0D46FA0FE5AD01420E74",
"S214FFF7A07A060002000001006FF60002401E01000C",
"S214FFF7B06B2600FFFC44FD1411361A0D46FAFD14A5",
"S214FFF7C010361A0D46FA01006FF600027A16000090",
"S214FFF7D00555FDAA68ED01006F7600027A16000057",
"S214FFF7E002AAFD5568ED01006F7600027A1600004A",
"S214FFF7F00555FDA068ED1AE6687E01006B2500FF43",
"S214FFF800FC440AD61AD5687D78506A2C00FFFC06A1",
"S214FFF81068EC1AE6687E01006B2500FFFC440AD6FA",
"S214FFF820686D1AE6687E78606A2500FFFC06E5804C",
"S214FFF8306AAD00FFFC49ED801C5D4608FE016EFECA",
"S214FFF8400001400A6A2E00FFFC49735E47C46E7EC5",
"S214FFF8500001AE0146024034687E01006B2500FFC2",
"S214FFF860FC440AD6686D1AE6687E78606A2500FF53",
"S214FFF870FC06E5806AAD00FFFC49ED801C5D460294",
"S214FFF880400AFE4F6AAE00FFFC00400A687E0A0E82",
"S214FFF89068FE5800FDFE1AE66A2E00FFFC481B961F",
"S214FFF8A01B061AD5687D1FD64F02400AFEF05C0085",
"S214FFF8B000F65800FC4C18EE3E423E437F40726016",
"S214FFF8C06A2E00FFFC006AAE00FFFC405C0000D81A",
"S214FFF8D040FE01006DF001006DF101006DF20100C8",
"S214FFF8E06DF301006DF401006DF56DFE6DF61B976F",
"S214FFF8F06F76000410166FF60002196669F66976D1",
"S214FFF9006F7500021D5644060B5669F640F00B97BE",
"S214FFF9100B876D7E01006D7501006D7401006D73C0",
"S214FFF92001006D7201006D7101006D705470010071",
"S214FFF9306DF001006DF101006DF201006DF3010045",
"S214FFF9406DF401006DF501006DF61B872EBCEE878A",
"S214FFF9503EBC7906EA6069F601006F76000218DDA4",
"S214FFF96068ED7EBC7360460A69761B5669F64702E9",
"S214FFF97040F06976460418EE401001006F760002EC",
"S214FFF9802DBD68ED7FBC7260FE010B970B870100F3",
"S214FFF9906D7501006D7401006D7301006D720100DD",
"S214FFF9A06D7101006D70547001006DF001006DF116",
"S214FFF9B001006DF201006DF301006DF401006DF5BD",
"S214FFF9C06DFE6DF67EBC7370460240F86E7E0001DB",
"S214FFF9D03EBB7FBC72700B876D7E01006D750100AC",
"S214FFF9E06D7401006D7301006D7201006D71010091",
"S208FFF9F06D7054706E",
"S9030000FC",
NULL
};

///* il programma usato e': wdlh8s01 */
//const char* H8S2345bootprogram[] = {
//"S00F000077646C68387330312E6133373C",
//"S20EFFF4007A0700FFFBFE5EFFF40A2A",
//"S214FFF40A01206DF418EE7A0000FFFAC418BB0CEA66",
//"S214FFF41AF20017720A8268AB8E01AE0143F018EE4D",
//"S214FFF42A7A0000FFFAD018BB0CEAF20017720A82BB",
//"S214FFF43A68AB8E01AE3F43F0FA306AAA00FFFAB015",
//"S214FFF44A7A0300FFFAB18A0168BA7A0300FFFAB2B2",
//"S214FFF45A8A0168BA7A0300FFFAB38A0168BA7A039E",
//"S214FFF46A00FFFAB48A0168BA7A0300FFFAB58A017E",
//"S214FFF47A68BA7A0300FFFAB68A0168BA7A0300FF07",
//"S214FFF48AFAB78A0168BA7A0300FFFAB88A0168BA35",
//"S214FFF49A7A0300FFFAB98A0168BA7A0300FFFABA52",
//"S214FFF4AAFA4168BA7A0300FFFABB8A0168BA7A0396",
//"S214FFF4BA00FFFABC8A0168BA7A0300FFFABD8A011E",
//"S214FFF4CA68BA7A0300FFFABE8A0168BA7A0300FFAF",
//"S214FFF4DAFABF8A0168BA7A03FFFFFF8018AA68BADA",
//"S214FFF4EA0B83683ACA3068BA1B03FA0C68BAF80183",
//"S214FFF4FA5EFFF9F418AA6AAA00FFFAA47A0000FFC8",
//"S214FFF50AFAA45EFFF9AE6A2A00FFFAA4AA0246DE4A",
//"S214FFF51AFA086AAA00FFFF427A03FFFFFFBE7902D4",
//"S214FFF52A5A7F69B21944F8045EFFF9F40CC85EFF05",
//"S214FFF53AF9F418AA6AAA00FFFAA47A0000FFFAA446",
//"S214FFF54A5EFFF9AE6A2A00FFFAA4AA0846D80B0499",
//"S214FFF55A7924000F43D0F8045EFFF9F418AA6AAAC2",
//"S214FFF56A00FFFAA47A0000FFFAA45EFFF9AE6A2A41",
//"S214FFF57A00FFFAA4AA0646DE18EE0CEAF2000D24ED",
//"S214FFF58A17740FC07A1000FFFAD05EFFF9AE0C8828",
//"S214FFF59A47F08E01AE0143E27A0300FFFAD0683ADB",
//"S214FFF5AAAA45587003BEAA504708FA4268BA5800D6",
//"S214FFF5BA03B27A0200FFFAD1682A6AAA00FFFAC8DB",
//"S214FFF5CAF84B5EFFF9F418EE401A0CEAF2000D2427",
//"S214FFF5DA17740FC07A1000FFFAD25EFFF9AE0C88D6",
//"S214FFF5EA47F08E016A2A00FFFAC81CAE45DC18AA45",
//"S214FFF5FA6AAA00FFFAC718EE6A2A00FFFAC8F200DC",
//"S214FFF60A0B0219001D204C347A0100FFFAD06A2A31",
//"S214FFF61A00FFFAC8F2000D200B006A2B00FFFAC79C",
//"S214FFF62A0CEAF20017720A92682A08AB8E010CEAF5",
//"S214FFF63AF2001D024DEA6AAB00FFFAC70CEAF200B7",
//"S214FFF64A17727A0000FFFAD06A2B00FFFAC77820F3",
//"S214FFF65A6A2A00FFFAD01CAB4708FA43688A5800A2",
//"S214FFF66A03027A0200FFFAD2682AF2000FA30CB34B",
//"S214FFF67A18BB0D3B19337A0200FFFAD3682AF20049",
//"S214FFF68A0D2A19220AA37A0200FFFAD4682A1072F0",
//"S214FFF69A1072107210727A620000FF000AA37A02D2",
//"S214FFF6AA00FFFAD5682AF20017720AA301006BA3B5",
//"S214FFF6BA00FFFAC018EE6A2A00FFFAC8F2001B9289",
//"S214FFF6CA1B0219331D234C3E6A2A00FFFAC8F200B2",
//"S214FFF6DA0D201B901B000CEAF2000D2317730B92EA",
//"S214FFF6EA0B8217F278206A2A00FFFAD078306AAAC5",
//"S214FFF6FA00FFFB2078306AAA00FFFA808E010CEA28",
//"S214FFF70AF2001D024DD001006B2200FFFAC07A22DA",
//"S214FFF71A0001FFFF5820020818AA6AAA00FFFB107A",
//"S214FFF72A6A2800FFFFC8C8406AA800FFFFC86A2AFF",
//"S214FFF73A00FFFB108A016AAA00FFFB1018AA6AAA32",
//"S214FFF74A00FFFAC67900000A5EFFF99E18EE6A2ADB",
//"S214FFF75A00FFFAC8F2001B921B0219331D234C3214",
//"S214FFF76A7A0000FFFA800CEAF200177201006B2398",
//"S214FFF77A00FFFAC00AA30A82682A68BA8E010CEB4F",
//"S214FFF78AF3006A2A00FFFAC8F2001B921B021D2327",
//"S214FFF79A4DD479025A006BA2FFFFFFBC7902A53A45",
//"S214FFF7AA6BA2FFFFFFBC7A0400FFFFC97D40700013",
//"S214FFF7BA790000325EFFF99E6A2800FFFFC8C8017B",
//"S214FFF7CA6AA800FFFFC8790000AA5EFFF99E6A2AA8",
//"S214FFF7DA00FFFFC8EAFE6AAA00FFFFC87900000A10",
//"S214FFF7EA5EFFF99E7D4072007900000A5EFFF99E71",
//"S214FFF7FA7902A51C6BA2FFFFFFBC6A2B00FFFFC89E",
//"S214FFF80ACB046AAB00FFFFC8790000045EFFF99ECF",
//"S214FFF81A18EE6A2A00FFFAC8F2001B921B021900AA",
//"S214FFF82A1D2058C0008E0CEDF5000D54177401000C",
//"S214FFF83A6B2300FFFAC00AC3FAFF68BA7900000210",
//"S214FFF84A5EFFF99E01006B2300FFFAC00AC30FC0D2",
//"S214FFF85A7A1000FFFA8069317A1400FFFB20684AA3",
//"S214FFF86A170A683B16BA170A688A0B050D5217F26B",
//"S214FFF87A0FA37A1300FFFA807A1200FFFB20682A8A",
//"S214FFF88A170A169A0CA9170968B9680AAAFF46043E",
//"S214FFF89AA9FF4708FA016AAA00FFFAC68E020CEB0E",
//"S214FFF8AAF3006A2A00FFFAC8F2001B921B021D2306",
//"S214FFF8BA58D0FF726A2A00FFFFC8EAFB6AAA00FF4F",
//"S214FFF8CAFFC8790000055EFFF99EF84E5EFFF9F461",
//"S214FFF8DAF8545EFFF9F46A2800FFFB105EFFF9F49E",
//"S214FFF8EA6A2A00FFFAC6470C6A2A00FFFB10AA9587",
//"S214FFF8FA5830FE3A6A2B00FFFFC8EBBF6AAB00FF21",
//"S214FFF90AFFC86A2A00FFFB10AA96460AF8F15EFFAE",
//"S214FFF91AF9F45800FC62F8F05EFFF9F45800FC5858",
//"S214FFF92A01006B2400FFFAC0F8F25EFFF9F40FC27B",
//"S214FFF93A0DA20C2A175217720CA85EFFF9F40FC213",
//"S214FFF94A0DA219AA0CA85EFFF9F40FC21172117262",
//"S214FFF95A117211720CA85EFFF9F40CC85EFFF9F477",
//"S214FFF96A5800FC1418AA6AAA00FFFFCA7A0300FF07",
//"S214FFF97AFFCB68BA6A2A00FFFFC8EABF6AAA00FF77",
//"S214FFF98AFFC86A2800FFFAD06AA800FFFAC45EFF1B",
//"S214FFF99AF9F440FE090019221D0244060B021D0255",
//"S214FFF9AA45FA54707A03FFFFFF84683AEA8768BA13",
//"S214FFF9BA7903EA607A01FFFFFF84681A736A4606CC",
//"S214FFF9CA1B030D3346F40D33471C7A02FFFFFF85F0",
//"S214FFF9DA682A688A7A03FFFFFF84683AEABF68BA2A",
//"S214FFF9EA790000014002190054707A03FFFFFF8472",
//"S214FFF9FA683A4CFC7A02FFFFFF8368A87A03FFFF88",
//"S20EFFFA0AFF84683AEA7F68BA54707A",
//"S804FFF40008",
//NULL
//};

/* il programma usato e': wdlh8s03  -- alcune porte sono modificate e non va bene.
const char* H8S2345bootprogram[] = {
"S00F000077646C68387330332E6133373A",
"S20EFFF4007A0700FFFBFE5EFFF40A2A",
"S214FFF40A01206DF47A03FFFFFEBD683ACAD068BAD8",
"S214FFF41A7A03FFFFFF6D683ACAD068BA6A38FFFFF9",
"S214FFF42AFED5725018EE7A0000FFFAC418BB0CEA33",
"S214FFF43A175217720A8268AB8E01AE0143F018EEB6",
"S214FFF44A7A0000FFFAD018BB0CEA175217720A8224",
"S214FFF45A68AB8E01AE3F43F0FA306AAA00FFFAB0F5",
"S214FFF46AFB317A0200FFFAB168AB8B017A0200FF22",
"S214FFF47AFAB268AB8B017A0200FFFAB368AB8B016C",
"S214FFF48A7A0200FFFAB468AB8B017A0200FFFAB57C",
"S214FFF49A68AB8B017A0200FFFAB668AB8B017A0279",
"S214FFF4AA00FFFAB768AB8B017A0200FFFAB868ABBF",
"S214FFF4BA8B017A0200FFFAB968ABFB417A0200FFBA",
"S214FFF4CAFABA68AB8B017A0200FFFABB68AB8B010C",
"S214FFF4DA7A0200FFFABC68AB8B017A0200FFFABD1C",
"S214FFF4EA68AB8B017A0200FFFABE68AB8B017A0221",
"S214FFF4FA00FFFABF68AB18AA6AAAFFFFFF807A0363",
"S214FFF50AFFFFFF82683ACA3068BAFA0C6AAAFFFF98",
"S214FFF51AFF81F8015EFFF9A418AA6AAA00FFFAA4F7",
"S214FFF52A7A0000FFFAA45EFFF96A6A2A00FFFAA4C5",
"S214FFF53AAA0246DEFA083A4279025A7F6BA2FFFF10",
"S214FFF54AFFBE18CC1AA20B027A22000124F743F652",
"S214FFF55AF8045EFFF9A40CC85EFFF9A418AA6AAA03",
"S214FFF56A00FFFAA47A0000FFFAA45EFFF96A6A2A85",
"S214FFF57A00FFFAA4AA0846CC8C01AC0F43C6F804CF",
"S214FFF58A5EFFF9A418AA6AAA00FFFAA47A0000FF87",
"S214FFF59AFAA45EFFF96A6A2A00FFFAA4AA0646DEFA",
"S214FFF5AA18EE0CEA17520D2417740FC07A1000FFD4",
"S214FFF5BAFAD05EFFF96A0C8847F08E01AE0143E285",
"S214FFF5CA7A0300FFFAD0683AAA4558700366AA502B",
"S214FFF5DA4708FA4268BA5800035A7A0200FFFAD175",
"S214FFF5EA682A6AAA00FFFAC8F84B5EFFF9A418EE63",
"S214FFF5FA401A0CEA17520D2417740FC07A1000FF30",
"S214FFF60AFAD25EFFF96A0C8847F08E016A2A00FF73",
"S214FFF61AFAC81CAE45DC18AA6AAA00FFFAC718EE93",
"S214FFF62A6A2A00FFFAC817520B0219001D204C2639",
"S214FFF63A7A0100FFFAD00D2018BB0CEA1752177290",
"S214FFF64A0A92682A08AB8E010CEA17521D024DEA87",
"S214FFF65A6AAB00FFFAC70CEA175217727A0000FF66",
"S214FFF66AFAD06A2B00FFFAC778206A2A00FFFAD078",
"S214FFF67A1CAB4708FA43688A580002B87A0200FFAA",
"S214FFF68AFAD2682817500C8018880D0819007A02D3",
"S214FFF69A00FFFAD3682A17520D2A19220AA07A02FD",
"S214FFF6AA00FFFAD4682B1073107310731073EB00F5",
"S214FFF6BA19BB7A0200FFFAD5682A17520AB014A8AD",
"S214FFF6CA01006BA000FFFAC018EE6A2A00FFFAC80C",
"S214FFF6DA17520D207912FFFB19331D234C360CEAFD",
"S214FFF6EA17520D2317737912000617F278206A2A23",
"S214FFF6FA00FFFAD078306AAA00FFFB2078306AAAA1",
"S214FFF70A00FFFA808E010CEB17530D027912FFFBEE",
"S214FFF71A1D234DCA01006B2200FFFAC07A220001A0",
"S214FFF72AFFFF582001CA18AA6AAA00FFFB107FC863",
"S214FFF73A70606A2A00FFFB108A016AAA00FFFB10A4",
"S214FFF74A18AA6AAA00FFFAC67900000A5EFFF95AE3",
"S214FFF75A18EE6A2A00FFFAC817527912FFFB190039",
"S214FFF76A1D204C327A0000FFFA800CEA17521772F5",
"S214FFF77A01006B2300FFFAC00AA30A82682A68BA46",
"S214FFF78A8E010CEB17536A2A00FFFAC81752791232",
"S214FFF79AFFFB1D234DD479025A006BA2FFFFFFBC65",
"S214FFF7AA7902A53A6BA2FFFFFFBC7A0400FFFFC9E6",
"S214FFF7BA7D407000790000325EFFF95A7FC87000FC",
"S214FFF7CA790000AA5EFFF95A7FC872007900000A1C",
"S214FFF7DA5EFFF95A7D4072007900000A5EFFF95A09",
"S214FFF7EA7902A51C6BA2FFFFFFBC7FC870207900B9",
"S214FFF7FA00045EFFF95A18EE6A2A00FFFAC8175283",
"S214FFF80A7912FFFB19111D2158C0008C0CED1755F4",
"S214FFF81A0D54177401006B2300FFFAC00AC3FAFFE0",
"S214FFF82A68BA790000025EFFF95A01006B2300FFEF",
"S214FFF83AFAC00AC30FC07A1000FFFA8069317A1439",
"S214FFF84A00FFFB20684A170A683B16BA170A688A37",
"S214FFF85A0B0517F50FD37A1300FFFA807A1500FF08",
"S214FFF86AFB20685A170A169A0CA9170968B9680A74",
"S214FFF87AAAFF4604A9FF4708FA016AAA00FFFAC6C2",
"S214FFF88A8E020CEB17536A2A00FFFAC81752791230",
"S214FFF89AFFFB1D2358D0FF747FC87220790000052E",
"S214FFF8AA5EFFF95AF84E5EFFF9A4F8545EFFF9A414",
"S214FFF8BA6A2800FFFB105EFFF9A46A2A00FFFAC651",
"S214FFF8CA470C6A2A00FFFB10AAEF5830FE647FC86F",
"S214FFF8DA72606A2A00FFFB10AAF0460AF8F15EFF7A",
"S214FFF8EAF9A45800FCBAF8F05EFFF9A45800FCB079",
"S214FFF8FA01006B2400FFFAC0F8F25EFFF9A40FC2FC",
"S214FFF90A0DA20C2A175217720CA85EFFF9A40FC293",
"S214FFF91A0DA219AA0CA85EFFF9A40FC211721172E2",
"S214FFF92A117211720CA85EFFF9A40CC85EFFF9A447",
"S214FFF93A5800FC6C6A2800FFFAD06AA800FFFAC4CF",
"S214FFF94A5EFFF9A418AA3ACA3ACB7FC8726040FE8D",
"S214FFF95A090019221D0244060B021D0245FA5470BD",
"S214FFF96A7A03FFFFFF84683AEA8768BA7902EA6091",
"S214FFF97A7C30736046061B020D2246F40D224604AF",
"S214FFF98A190040146A2AFFFFFF85688A6A38FFFF54",
"S214FFF99AFF8472607900000154707A03FFFFFF84C8",
"S214FFF9AA683AEA8047FA6AA8FFFFFF836A38FFFFCA",
"S20AFFF9BAFF84727054701A",
"S804FFF40008",
NULL
};
*/

/* porta l'abilitaizone del watchdog prima della
  emulaizone cancellazione settori esterni
 */
const char* H8S2345bootprogram[] = {
"S00F000077646C68387330342E61333739",
"S20EFFF4007A0700FFFBFE5EFFF40A2A",
"S214FFF40A01206DF46A38FFFFFED5725018EE7A00B7",
"S214FFF41A00FFFAC418BB0CEA175217720A8268ABC7",
"S214FFF42A8E01AE0143F018EE7A0000FFFAD018BB41",
"S214FFF43A0CEA175217720A8268AB8E01AE3F43F088",
"S214FFF44AFA306AAA00FFFAB0FB317A0200FFFAB175",
"S214FFF45A68AB8B017A0200FFFAB268AB8B017A02BD",
"S214FFF46A00FFFAB368AB8B017A0200FFFAB468AB07",
"S214FFF47A8B017A0200FFFAB568AB8B017A0200FFAE",
"S214FFF48AFAB668AB8B017A0200FFFAB768AB8B0154",
"S214FFF49A7A0200FFFAB868AB8B017A0200FFFAB964",
"S214FFF4AA68ABFB417A0200FFFABA68AB8B017A02B5",
"S214FFF4BA00FFFABB68AB8B017A0200FFFABC68ABA7",
"S214FFF4CA8B017A0200FFFABD68AB8B017A0200FF56",
"S214FFF4DAFABE68AB8B017A0200FFFABF68AB18AABE",
"S214FFF4EA6AAAFFFFFF807A03FFFFFF82683ACA30E5",
"S214FFF4FA68BAFA0C6AAAFFFFFF81F8015EFFF98E67",
"S214FFF50A18AA6AAA00FFFAA47A0000FFFAA45EFF06",
"S214FFF51AF9546A2A00FFFAA4AA0246DEFA083A4211",
"S214FFF52A79025A7F6BA2FFFFFFBE18CC1AA20B0204",
"S214FFF53A7A22000124F743F6F8045EFFF98E0CC818",
"S214FFF54A5EFFF98E18AA6AAA00FFFAA47A0000FFDD",
"S214FFF55AFAA45EFFF9546A2A00FFFAA4AA0846CC60",
"S214FFF56A8C01AC0F43C6F8045EFFF98E18AA6AAA86",
"S214FFF57A00FFFAA47A0000FFFAA45EFFF9546A2A8B",
"S214FFF58A00FFFAA4AA0646DE18EE0CEA17520D2466",
"S214FFF59A17740FC07A1000FFFAD05EFFF9540C8872",
"S214FFF5AA47F08E01AE0143E27A0300FFFAD0683ACB",
"S214FFF5BAAA4558700366AA504708FA4268BA58001E",
"S214FFF5CA035A7A0200FFFAD1682A6AAA00FFFAC823",
"S214FFF5DAF84B5EFFF98E18EE401A0CEA17520D2406",
"S214FFF5EA17740FC07A1000FFFAD25EFFF9540C8820",
"S214FFF5FA47F08E016A2A00FFFAC81CAE45DC18AA35",
"S214FFF60A6AAA00FFFAC718EE6A2A00FFFAC8175254",
"S214FFF61A0B0219001D204C267A0100FFFAD00D2096",
"S214FFF62A18BB0CEA175217720A92682A08AB8E01A1",
"S214FFF63A0CEA17521D024DEA6AAB00FFFAC70CEA3C",
"S214FFF64A175217727A0000FFFAD06A2B00FFFAC722",
"S214FFF65A78206A2A00FFFAD01CAB4708FA43688A62",
"S214FFF66A580002B87A0200FFFAD2682817500C80B0",
"S214FFF67A18880D0819007A0200FFFAD3682A17526B",
"S214FFF68A0D2A19220AA07A0200FFFAD4682B1073F1",
"S214FFF69A107310731073EB0019BB7A0200FFFAD5CA",
"S214FFF6AA682A17520AB014A801006BA000FFFAC016",
"S214FFF6BA18EE6A2A00FFFAC817520D207912FFFBC6",
"S214FFF6CA19331D234C360CEA17520D23177379127A",
"S214FFF6DA000617F278206A2A00FFFAD078306AAA5C",
"S214FFF6EA00FFFB2078306AAA00FFFA808E010CEB37",
"S214FFF6FA17530D027912FFFB1D234DCA01006B2219",
"S214FFF70A00FFFAC07A220001FFFF582001CA18AA92",
"S214FFF71A6AAA00FFFB107FC870606A2A00FFFB1008",
"S214FFF72A8A016AAA00FFFB1018AA6AAA00FFFAC68D",
"S214FFF73A7900000A5EFFF94218EE6A2A00FFFAC845",
"S214FFF74A17527912FFFB19001D204C327A0000FF70",
"S214FFF75AFA800CEA1752177201006B2300FFFAC0F1",
"S214FFF76A0AA30A82682A68BA8E010CEB17536A2A1A",
"S214FFF77A00FFFAC817527912FFFB1D234DD47902F0",
"S214FFF78A5A006BA2FFFFFFBC7902A53A6BA2FFFFE6",
"S214FFF79AFFBC7A0400FFFFC97D4070007900003283",
"S214FFF7AA5EFFF9427FC87000790000AA5EFFF94241",
"S214FFF7BA7FC872007900000A5EFFF9427D40720038",
"S214FFF7CA7900000A5EFFF9427902A51C6BA2FFFFC9",
"S214FFF7DAFFBC7FC87020790000045EFFF94218EE6E",
"S214FFF7EA6A2A00FFFAC817527912FFFB19111D2160",
"S214FFF7FA58C0008C0CED17550D54177401006B2377",
"S214FFF80A00FFFAC00AC3FAFF68BA790000025EFF71",
"S214FFF81AF94201006B2300FFFAC00AC30FC07A1031",
"S214FFF82A00FFFA8069317A1400FFFB20684A170A3C",
"S214FFF83A683B16BA170A688A0B0517F50FD37A13A9",
"S214FFF84A00FFFA807A1500FFFB20685A170A169AF5",
"S214FFF85A0CA9170968B9680AAAFF4604A9FF470848",
"S214FFF86AFA016AAA00FFFAC68E020CEB17536A2A37",
"S214FFF87A00FFFAC817527912FFFB1D2358D0FF74F0",
"S214FFF88A7FC87220790000055EFFF942F84E5EFFD8",
"S214FFF89AF98EF8545EFFF98E6A2800FFFB105EFFAA",
"S214FFF8AAF98E6A2A00FFFAC6470C6A2A00FFFB107F",
"S214FFF8BAAAEF5830FE647FC872606A2A00FFFB1000",
"S214FFF8CAAAF0460AF8F15EFFF98E5800FCBAF8F07D",
"S214FFF8DA5EFFF98E5800FCB001006B2400FFFAC0E9",
"S214FFF8EAF8F25EFFF98E0FC20DA20C2A1752177294",
"S214FFF8FA0CA85EFFF98E0FC20DA219AA0CA85EFF0E",
"S214FFF90AF98E0FC211721172117211720CA85EFF74",
"S214FFF91AF98E0CC85EFFF98E5800FC6C6A2800FF49",
"S214FFF92AFAD06AA800FFFAC45EFFF98E18AA3ACA86",
"S214FFF93A3ACB7FC8726040FE1050105019221D0243",
"S214FFF94A44060B021D0245FA54707A03FFFFFF8432",
"S214FFF95A683AEA8768BA7902EA607C3073604606D4",
"S214FFF96A1B020D2246F40D224604190040146A2A89",
"S214FFF97AFFFFFF85688A6A38FFFFFF847260790097",
"S214FFF98A000154707A03FFFFFF84683AEA8047FA59",
"S214FFF99A6AA8FFFFFF836A38FFFFFF8472705470FE",
"S804FFF40008",
NULL
};

/* Abilita il WTD sol dop aver emulato la cancellazione
  della flash esterna da 16 settori
  */
const char* H8S2345Z24Ebootprogram[] = {
    "S0120000683873323334357A3234452E613337EE",
    "S20EFFF4007A0700FFFBFE5EFFF40A2A",
    "S214FFF40A01206DF46A38FFFFFED5725018EE7A00B7",
    "S214FFF41A00FFFAC418BB0CEA175217720A8268ABC7",
    "S214FFF42A8E01AE0143F018EE7A0000FFFAD018BB41",
    "S214FFF43A0CEA175217720A8268AB8E01AE3F43F088",
    "S214FFF44AFA306AAA00FFFAB0FB317A0200FFFAB175",
    "S214FFF45A68AB8B017A0200FFFAB268AB8B017A02BD",
    "S214FFF46A00FFFAB368AB8B017A0200FFFAB468AB07",
    "S214FFF47A8B017A0200FFFAB568AB8B017A0200FFAE",
    "S214FFF48AFAB668AB8B017A0200FFFAB768AB8B0154",
    "S214FFF49A7A0200FFFAB868AB8B017A0200FFFAB964",
    "S214FFF4AA68ABFB417A0200FFFABA68AB8B017A02B5",
    "S214FFF4BA00FFFABB68AB8B017A0200FFFABC68ABA7",
    "S214FFF4CA8B017A0200FFFABD68AB8B017A0200FF56",
    "S214FFF4DAFABE68AB8B017A0200FFFABF68AB18AABE",
    "S214FFF4EA6AAAFFFFFF807A03FFFFFF82683ACA30E5",
    "S214FFF4FA68BAFA0C6AAAFFFFFF81F8015EFFF98E67",
    "S214FFF50A18AA6AAA00FFFAA47A0000FFFAA45EFF06",
    "S214FFF51AF9546A2A00FFFAA4AA0246DE18CC1AA2EF",
    "S214FFF52A0B027A22000124F743F6F8045EFFF98EEF",
    "S214FFF53A0CC85EFFF98E18AA6AAA00FFFAA47A0018",
    "S214FFF54A00FFFAA45EFFF9546A2A00FFFAA4AA0883",
    "S214FFF55A46CC8C01AC0F43C6F8045EFFF98E18AA98",
    "S214FFF56A6AAA00FFFAA47A0000FFFAA45EFFF9541B",
    "S214FFF57A6A2A00FFFAA4AA0646DEFA083A4279027F",
    "S214FFF58A5A7F6BA2FFFFFFBE18EE0CEA17520D2436",
    "S214FFF59A17740FC07A1000FFFAD05EFFF9540C8872",
    "S214FFF5AA47F08E01AE0143E27A0300FFFAD0683ACB",
    "S214FFF5BAAA4558700366AA504708FA4268BA58001E",
    "S214FFF5CA035A7A0200FFFAD1682A6AAA00FFFAC823",
    "S214FFF5DAF84B5EFFF98E18EE401A0CEA17520D2406",
    "S214FFF5EA17740FC07A1000FFFAD25EFFF9540C8820",
    "S214FFF5FA47F08E016A2A00FFFAC81CAE45DC18AA35",
    "S214FFF60A6AAA00FFFAC718EE6A2A00FFFAC8175254",
    "S214FFF61A0B0219001D204C267A0100FFFAD00D2096",
    "S214FFF62A18BB0CEA175217720A92682A08AB8E01A1",
    "S214FFF63A0CEA17521D024DEA6AAB00FFFAC70CEA3C",
    "S214FFF64A175217727A0000FFFAD06A2B00FFFAC722",
    "S214FFF65A78206A2A00FFFAD01CAB4708FA43688A62",
    "S214FFF66A580002B87A0200FFFAD2682817500C80B0",
    "S214FFF67A18880D0819007A0200FFFAD3682A17526B",
    "S214FFF68A0D2A19220AA07A0200FFFAD4682B1073F1",
    "S214FFF69A107310731073EB0019BB7A0200FFFAD5CA",
    "S214FFF6AA682A17520AB014A801006BA000FFFAC016",
    "S214FFF6BA18EE6A2A00FFFAC817520D207912FFFBC6",
    "S214FFF6CA19331D234C360CEA17520D23177379127A",
    "S214FFF6DA000617F278206A2A00FFFAD078306AAA5C",
    "S214FFF6EA00FFFB2078306AAA00FFFA808E010CEB37",
    "S214FFF6FA17530D027912FFFB1D234DCA01006B2219",
    "S214FFF70A00FFFAC07A220001FFFF582001CA18AA92",
    "S214FFF71A6AAA00FFFB107FC870606A2A00FFFB1008",
    "S214FFF72A8A016AAA00FFFB1018AA6AAA00FFFAC68D",
    "S214FFF73A7900000A5EFFF94218EE6A2A00FFFAC845",
    "S214FFF74A17527912FFFB19001D204C327A0000FF70",
    "S214FFF75AFA800CEA1752177201006B2300FFFAC0F1",
    "S214FFF76A0AA30A82682A68BA8E010CEB17536A2A1A",
    "S214FFF77A00FFFAC817527912FFFB1D234DD47902F0",
    "S214FFF78A5A006BA2FFFFFFBC7902A53A6BA2FFFFE6",
    "S214FFF79AFFBC7A0400FFFFC97D4070007900003283",
    "S214FFF7AA5EFFF9427FC87000790000AA5EFFF94241",
    "S214FFF7BA7FC872007900000A5EFFF9427D40720038",
    "S214FFF7CA7900000A5EFFF9427902A51C6BA2FFFFC9",
    "S214FFF7DAFFBC7FC87020790000045EFFF94218EE6E",
    "S214FFF7EA6A2A00FFFAC817527912FFFB19111D2160",
    "S214FFF7FA58C0008C0CED17550D54177401006B2377",
    "S214FFF80A00FFFAC00AC3FAFF68BA790000025EFF71",
    "S214FFF81AF94201006B2300FFFAC00AC30FC07A1031",
    "S214FFF82A00FFFA8069317A1400FFFB20684A170A3C",
    "S214FFF83A683B16BA170A688A0B0517F50FD37A13A9",
    "S214FFF84A00FFFA807A1500FFFB20685A170A169AF5",
    "S214FFF85A0CA9170968B9680AAAFF4604A9FF470848",
    "S214FFF86AFA016AAA00FFFAC68E020CEB17536A2A37",
    "S214FFF87A00FFFAC817527912FFFB1D2358D0FF74F0",
    "S214FFF88A7FC87220790000055EFFF942F84E5EFFD8",
    "S214FFF89AF98EF8545EFFF98E6A2800FFFB105EFFAA",
    "S214FFF8AAF98E6A2A00FFFAC6470C6A2A00FFFB107F",
    "S214FFF8BAAAEF5830FE647FC872606A2A00FFFB1000",
    "S214FFF8CAAAF0460AF8F15EFFF98E5800FCBAF8F07D",
    "S214FFF8DA5EFFF98E5800FCB001006B2400FFFAC0E9",
    "S214FFF8EAF8F25EFFF98E0FC20DA20C2A1752177294",
    "S214FFF8FA0CA85EFFF98E0FC20DA219AA0CA85EFF0E",
    "S214FFF90AF98E0FC211721172117211720CA85EFF74",
    "S214FFF91AF98E0CC85EFFF98E5800FC6C6A2800FF49",
    "S214FFF92AFAD06AA800FFFAC45EFFF98E18AA3ACA86",
    "S214FFF93A3ACB7FC8726040FE1050105019221D0243",
    "S214FFF94A44060B021D0245FA54707A03FFFFFF8432",
    "S214FFF95A683AEA8768BA7902EA607C3073604606D4",
    "S214FFF96A1B020D2246F40D224604190040146A2A89",
    "S214FFF97AFFFFFF85688A6A38FFFFFF847260790097",
    "S214FFF98A000154707A03FFFFFF84683AEA8047FA59",
    "S214FFF99A6AA8FFFFFF836A38FFFFFF8472705470FE",
    "S804FFF40008",
    NULL
};

/* il programma usato e': dld */
const char* SH27044bootprogram[] = {
"S00E0000646C6420202020206D6F74CD",
"S315FFFFF000DF03D204420B00094F26AFFE00090000C3",
"S30DFFFFF010FFFFF700FFFFF018F9",
"S315FFFFF018D4567FDCEE0065E324E075027401635C7A",
"S315FFFFF02824E0E20233238FF7740165E3D950E40046",
"S315FFFFF038349CE64024E075027401625C24E0326387",
"S315FFFFF0488FF87401D44BE2302420E0318041E0325F",
"S315FFFFF0588042E0338043E0348044E0358045E03644",
"S315FFFFF0688046E0378047E0388048E0398049E0410D",
"S315FFFFF078804AE042804BE043804CE044804DE045C8",
"S315FFFFF088804EE046804F9469844BCB40804B844A41",
"S315FFFFF098CB01804A9463634373026030C9FC230044",
"S315FFFFF0A862436020C9FC2200E01680418442CB20E0",
"S315FFFFF0B880428442CB108042DD2FB1FFE401D42E7C",
"S315FFFFF0C8B1D02DE060D0600C88028BF6944884415E",
"S315FFFFF0D8C9FB80418441C9FD80418441C9FE804106",
"S315FFFFF0E8923F933F23216CE3EB10B1E7E404B1E5CD",
"S315FFFFF0F864C3D421B1B62DE060D0600C88088BF4C9",
"S30BFFFFF1087C013CB28BF116",
"S315FFFFF10EB1D9E404D41BB1AA2DE060D0600C8806FA",
"S315FFFFF11E8BF698256493DA176293DB1765939C201C",
"S315FFFFF12E7203DD1663531F526153730171021F3450",
"S315FFFFF13E63431F5273041F1674051F271F351F4385",
"S315FFFFF14E60E380F4E300339C2F32B18864F2600CE8",
"S315FFFFF15E2008A0160009838481B086285A5F86127F",
"S309FFFFF16E00FF858095",
"S315FFFFF174FFFFF52CFFFFF4ECFFFFF4DCFFFFF57C4D",
"S315FFFFF184FFFFF570FFFFF56EFFFFF57489E2E202FD",
"S315FFFFF19484F4700180F463F273012F3284F4600CFC",
"S315FFFFF1A430238BD750F2600088458B01A1470009B6",
"S315FFFFF1B450F260008850890452F2E3422230A13EA6",
"S315FFFFF1C4000952F463202D30B17AE44B60E3E30088",
"S315FFFFF1D480F4339C73022F3262D0622C42158B0E5E",
"S315FFFFF1E4B14264F2600C200889FA84F4700180F45A",
"S315FFFFF1F463F273012F3284F462D030228BF0D31182",
"S315FFFFF20423E062D0622C720142158F0D64E3604CDA",
"S315FFFFF214D20C7401039C6120313C634C221062D0F3",
"S315FFFFF224622C720133238BF2D206644C6320604354",
"S315FFFFF234019C633C611C33108906E34351F2213081",
"S315FFFFF244A0FD0009FFFFF57652F6632052F7633CF4",
"S315FFFFF2546120432852F5611C43184128331C612062",
"S30BFFFFF26452F3611C411885",
"S315FFFFF26A331C6120611C331C2A3263D0633C73FB58",
"S315FFFFF27A43158F1264E3D347654CD047335C665316",
"S315FFFFF28A369C76067401626023206360624C0534FE",
"S315FFFFF29A63D0633C73FB32338BED64A2D3403432C4",
"S315FFFFF2AA8B01A0B700092BE060C0CB402C0063B0EF",
"S315FFFFF2BA73012B30D23B22E0B0C7E40A62D0622C3D",
"S315FFFFF2CA72FB42158F0D64E3654C63A27401D0325C",
"S315FFFFF2DA335C025C232062D0634C622C72FB3323BE",
"S315FFFFF2EA8BF2925493542321D12F231160C0CB1053",
"S315FFFFF2FA2C00B0AAE43260C0CB01944AB0A52C0019",
"S315FFFFF30A60C0C9FE2C00B0A0E40A60C0C9EF2C009A",
"S315FFFFF31AB09BE40AD225933B232160C0CB042C0082",
"S315FFFFF32AB093E404E00080F463D0633C73FB4315B8",
"S315FFFFF33A8B4A84F4600C2F0263A2303C2080B08490",
"S315FFFFF34AE40263A2E02062F2323C61210F15D31277",
"S30BFFFFF35AE02064F2343CE3",
"S315FFFFF360D20F654366F2750100FC362C61606117AB",
"S315FFFFF37021096117241061F3846171216110600710",
"S315FFFFF3802019600725006140611C31808B15615094",
"S313FFFFF390611C3180A01000095A00861000AAEA",
"S315FFFFF3A0FFFFF52EFFFFF54E00020000FFFFF56F93",
"S315FFFFF3B00000A53A0000A51A8902E301D23E2230DA",
"S315FFFFF3C084F4700280F4600C63D0633C73FB3033CC",
"S315FFFFF3D08BB460C0C9FB2C00B03CE405B072E44EB1",
"S315FFFFF3E0B070E454B06E64B0D2336320233889061D",
"S315FFFFF3F061B0611C935A31338901AF5D000960C06B",
"S315FFFFF400C9BF2C0063B0633C925033208B02944EEE",
"S315FFFFF410A0010009944CB0550009AE9800091F489A",
"S315FFFFF4209447B04F0009E020B04C04FCE021B049FF",
"S315FFFFF43004FCE022B04604FCE023B04304FCAE86A6",
"S315FFFFF4400009D31E2F326290232064F2B03A644044",
"S315FFFFF450AFFE000966434608656D45158F04E40058",
"S315FFFFF4607401624D32538BFB000B000995227FFC23",
"S315FFFFF4708454C9878054E640D3112F318454600CDE",
"S315FFFFF48020688B0562F172FF2F21622D22288BF5F3",
"S30BFFFFF49061F121188B025A",
"S315FFFFF496E000000B7F04845524008454C9BF8054C3",
"S315FFFFF4A6E001000B7F04009600F100F000F281B049",
"S315FFFFF4B8FFFFF56FFFFFF52C0000EA609509605324",
"S315FFFFF4C88404C88089FB604380538454C97F000B3B",
"S309FFFFF4D8805481B027",
"S705FFFFF0000C",
NULL
};

/* il programma usato e': dld */
const char* SH27044Fbootprogram[] = {
"S00E0000646C6430322020206D6F74AB",
"S315FFFFF000DF03D204420B00094F26AFFE00090000C3",
"S30DFFFFF010FFFFF880FFFFF01878",
"S315FFFFF01894C77FDC8449CB4080498448CB1080481E",
"S315FFFFF0288448CB018048634373156030C9F3CB0827",
"S315FFFFF0382300624372156020C9FCCB02220063439B",
"S315FFFFF04873166030C93FCB80230062437216602078",
"S315FFFFF058C9CFCB202200634373176030CB0423004D",
"S315FFFFF068624372176020CB012200D04F814C634366",
"S315FFFFF07873296030CB012300624372296020CB02DC",
"S315FFFFF0882200634373296030CB042300624372294E",
"S315FFFFF0986020CB082200634373296030CB1023001F",
"S315FFFFF0A8624372296020CB202200634373296030B5",
"S315FFFFF0B8CB402300624372296020CB8022009571E3",
"S315FFFFF0C88451C9DF80518451C9FD8051635373024F",
"S315FFFFF0D86030C9F3CB0C23008453CB208053845372",
"S315FFFFF0E8CB028053625372056020C90FCBF0220013",
"S315FFFFF0F8D52EEE0066E3760125E0E202636C332345",
"S30BFFFFF1088FF97501D92AFC",
"S315FFFFF10EE50066E3E740359C760125E0626C3273D8",
"S315FFFFF11E8FFA7501E230D525E03125208051E03299",
"S315FFFFF12E8052E0338053E0348054E0358055E0362D",
"S315FFFFF13E8056E0378057E0388058E0398059E041F6",
"S315FFFFF14E805AE042805BE043805CE044805DE045B1",
"S315FFFFF15E805EE046805F844BCB40804B844ACB017B",
"S315FFFFF16E804A941D634373026030C9FC23006243DA",
"S315FFFFF17E6020C9FC2200E01680418442CB208042EC",
"S315FFFFF18E8442CB108042DD0AB253E401D409B2307A",
"S315FFFFF19E2DE060D0600C8802A00D000983848620C7",
"S315FFFFF1AE81B00000FFFFFFFFF6ACFFFFF66CFFFF20",
"S315FFFFF1BEF65CFFFFF6FD8BE7946E8441C9FB80413C",
"S315FFFFF1CE8441C9FD80418441C9FE804192659365A5",
"S315FFFFF1DE23219A64E8016CA37C486BE39260D330DC",
"S315FFFFF1EE2320B1EF64C3D22FE3552230B1EA64C3B6",
"S30BFFFFF1FED22C22A0B1E6B0",
"S315FFFFF20464C39252D3292320B1E164C3D228E355C1",
"S315FFFFF2142230B1DC64C362BCD026E3304228023419",
"S315FFFFF224B1D564C3D22463BCD122432822E0331C65",
"S315FFFFF2342F3262F2D121632021306210622C22A980",
"S315FFFFF24432A08B02D21CA00D2280B1F7E403B1F5E5",
"S315FFFFF25464B3D41BB1D22DE0D3186030600CC92040",
"S315FFFFF26488208BE6D314628C22288D0D2380B1E58B",
"S315FFFFF274E404B1E364B3D412B1C02DE060D0600CF3",
"S315FFFFF28488088BF4A01E0009B1D8E405B1D664B390",
"S315FFFFF294D40BB1B32DE060D0600C88078BF4AFFEBF",
"S315FFFFF2A4000986285A5F8612008000AA004005558A",
"S315FFFFF2B4004002AA00400000FFFFF6FCFFFFF6F541",
"S315FFFFF2C4FFFFF6FD7B0163BCE22033238B8BB1B5D6",
"S315FFFFF2D4E404D432B1922DE060D0600C88068BF63D",
"S315FFFFF2E4DA2F6493DB2F6293DC2F65939D557203AD",
"S30BFFFFF2F41F526353730175",
"S315FFFFF2FA61531F3571021F5263431F1773041F237F",
"S315FFFFF30A74051F361F4460E3E30080F4339C2F32F4",
"S315FFFFF31AB17164F2600C200889FA84F4E202700183",
"S315FFFFF32A80F463F273012F3284F4600C30238BEF80",
"S315FFFFF33A50F260008845890650F260008850890BB3",
"S315FFFFF34AE34252F22230D3172F326290232064F21E",
"S315FFFFF35AB1716440A136000952F563202C30B16AB8",
"S315FFFFF36AE44B60E3E30080F4339CA00A7302B142E5",
"S315FFFFF37A64F2600C200889FA84F4700180F463F260",
"S315FFFFF38A73012F3284F463C030328BF0D30723E045",
"S315FFFFF39AA01464E38580FFFFF6FDFFFFF6F0FFFF8C",
"S315FFFFF3AAF6EEFFFFF6F4FFFFF6ACFFFFF6F6D244E3",
"S315FFFFF3BA604C61207401039C313C2210634C62C08E",
"S315FFFFF3CA622C720133238BF2644CD23D6043632076",
"S315FFFFF3DA633C019C611C3310890451F2E3432130DC",
"S30BFFFFF3EAAFB1000952F767",
"S315FFFFF3F06320633C52F343286120431852F6611C96",
"S315FFFFF4004128331C6120611C52F44118331C6120D3",
"S315FFFFF410611C331C2A32A00C64E3654CD32C665364",
"S315FFFFF420D02C7401335C369C7606626023206360C2",
"S315FFFFF4300534624C63C0633C73FB32338BED64A2CE",
"S315FFFFF440D32534328B01A0B000092BE060D0CB402F",
"S315FFFFF4502D0063B0D22173012B3022E0B0B9E40A4D",
"S315FFFFF460A00764E363A2654CD01A335C025C7401A8",
"S315FFFFF4702320634C62C0622C72FB33238BF29222F2",
"S315FFFFF48093222321D116231160D0CB102D00B0A0DC",
"S315FFFFF490E43260D0CB019418B09B2D0060D0C9FE3B",
"S315FFFFF4A02D00B096E40A60D0C9EF2D00B091E40AB3",
"S315FFFFF4B0D20C9309232160D0CB042D00B089E4043D",
"S315FFFFF4C060E3A04580F45A00861000AAFFFFF6F618",
"S315FFFFF4D0FFFFF6AEFFFFF6CE00020000FFFFF6EFDF",
"S309FFFFF4E00000A53A45",
"S315FFFFF4E40000A51A84F4600C2F0263A2927B303CC2",
"S315FFFFF4F42020B06CE402E02063A262F2323C612179",
"S315FFFFF504D33B0F1564F2E020D23A343C65F26643EF",
"S315FFFFF51400FC352C61507601611721096117241010",
"S315FFFFF524845161F36007712161102019600726007A",
"S315FFFFF5346140611C905731008B036160611C310090",
"S315FFFFF5448901D22D228084F4700280F484F4600C46",
"S315FFFFF55463C0633C73FB30338BC460D0C9FB2D00A0",
"S315FFFFF564B035E405B06AE44EB068E454B06664B0FF",
"S315FFFFF574D22163202338890661B0611C933431336A",
"S315FFFFF5848901AF64000960D0C9BF2D0063B0633C36",
"S315FFFFF594922A33208B029428A00100099426B04DAA",
"S315FFFFF5A40009AEB300091F489421B0470009E020C4",
"S315FFFFF5B4B04404FCE021B04104FCE022B03E04FC6D",
"S315FFFFF5C4E023B03B04FCAEA10009AFFE000966438E",
"S30BFFFFF5D44608656D4515B3",
"S315FFFFF5DA8F04E4007401624D32538BFB000B000963",
"S315FFFFF5EA00FF009600F100F000F2FFFFF6CEFFFFE5",
"S315FFFFF5FAF6AEFFFFF6EF95297FFC8454C987805441",
"S315FFFFF60AE640D3122F318454600C20688B0562F1D2",
"S315FFFFF61A72FF2F21622D22288BF561F121188B02AA",
"S315FFFFF62AE000000B7F04845524008454C9BF80542D",
"S315FFFFF63AE001000B7F04950960538404C88089FBA8",
"S315FFFFF64A604380538454C97F000B805481B0000006",
"S307FFFFF65AEA6060",
"S705FFFFF0000C",
NULL
};

/* il programma usato e': dld */
/* cancella flash esterna ed ospita codice su flash esterna */
const char* SH2MNJ600bootprogram[] = {
"S00F0000736832646C6430332E61343455",
"S315FFFFF000DF01D002400B0009FFFFF940FFFFF010C1",
"S315FFFFF0102F862F962FA62FB62FC62FD6D1762FE662",
"S315FFFFF0204F22410BEE0091D792D7212171F8711430",
"S315FFFFF030E20A212192D27102212192D0710221216E",
"S315FFFFF04092CE7110212191CC92CC212192CB7104CA",
"S315FFFFF0502121D16AE200601361E30E2471016E1C68",
"S315FFFFF060E1013E168BF5EE00D165E200601361E329",
"S315FFFFF0700E2471016E1CE13F3E168BF5EE00D26149",
"S315FFFFF08061E3713060230E1471D16E1CE1093E16E8",
"S315FFFFF0908FF761E3EE00D25B61E371417E0A602386",
"S315FFFFF0A00E1471C06E1CE1053E168FF661E3929B4F",
"S315FFFFF0B0919B2121919AE2302120E2162124D15200",
"S315FFFFF0C0D852410BE401D052E1002810400B648374",
"S315FFFFF0D0608088028BF3EE00928991892121D94DB9",
"S315FFFFF0E0EDAA9886EB55DA4C6483DC4C490B2AD0A4",
"S315FFFFF0F06483490B2CB0E1802A10490B6483648338",
"S315FFFFF100490B2AD06483490B2CB0D24560E3E1302B",
"S315FFFFF11040280214490B6483D142E200212060E3B9",
"S315FFFFF120D13F4028001CDA409964290929988D02AE",
"S315FFFFF1302A00A236E201D834480BE403480B64E306",
"S315FFFFF140D033D432400B249060A0C92020088DE72E",
"S315FFFFF15060E3D134E2012120D82B480BE404480BAE",
"S315FFFFF16064E3D02BE100D8292810400B648360802D",
"S315FFFFF17088088FF161E371016E1CE11F3E168BAEAE",
"S315FFFFF180D121D822410BE404D021E1002810400B06",
"S315FFFFF1906483608088068BF3EE00D01D64E3D91885",
"S315FFFFF1A0400B349C20088DF861E371016E1CE10171",
"S315FFFFF1B03E168FF26293602088458F028850A1E743",
"S315FFFFF1C000098902E142A1E32210619371016110F7",
"S315FFFFF1D0E44BD816A02CEE00838C1140A005FFFF51",
"S315FFFFF1E000FF8620200CFFF30140838E81B25A5F1A",
"S315FFFFF1F0861200C800800009FFFFF750FFFFF844A3",
"S315FFFFF200FFFFF850FFFFF830FFFFF644FFFFF8243C",
"S315FFFFF210FFFFF5FAFFFFF5E000400555004002AAA4",
"S315FFFFF22000400000FFFFF848FFFFF891FFFFF84996",
"S315FFFFF2302810D197410B0009A00C6180D09564E39C",
"S315FFFFF240D195400B341C20088DF861E371016E1CCC",
"S315FFFFF250D1926110611C3E128FF0E200D190212006",
"S315FFFFF260D18E6110601C88FF8D0FEE006713D28D64",
"S315FFFFF270D38B602302EC6130312C231061E37101E4",
"S315FFFFF2806E1C617C71013E138BF1D185D3856210B4",
"S315FFFFF290603301EC32108D02EE00A178E14361335A",
"S315FFFFF2A071026210710161104228611C41284218E8",
"S315FFFFF2B0321C613371046110611C4118321C6133CA",
"S315FFFFF2C071056110611C321CD1772122D173621047",
"S315FFFFF2D0612C71FB3E1389126323D1727E06601385",
"S315FFFFF2E002ECD1727EFA60130E24D171601361E3D3",
"S315FFFFF2F00E2471016E1C613C71FB3E138BEDD16ACF",
"S315FFFFF3006212D16C32168B69D16B32168B59EE00B6",
"S315FFFFF310D1626110E900D869611C71FB3E138D4014",
"S315FFFFF320282992A9E1AA328C221090A6E15508144A",
"S315FFFFF330E1A02210D15C6212D15C601301EC602365",
"S315FFFFF3400E14D15F410BE432D1576012D15D02EC4F",
"S315FFFFF3502120D156601301EC6013918FC9802129BB",
"S315FFFFF36031008D396023C920200889ED609388011C",
"S315FFFFF3708D0F61E3D14C6012D15202EC2120D14BAC",
"S315FFFFF380601301EC60139179C980221932008F1F38",
"S315FFFFF39061E371016E1CD1416110611C71FB3E136C",
"S315FFFFF3A08BBFD83B480BE44E480BE454480BE401B4",
"S315FFFFF3B0D13A6110611C71FB3E108904945F480BC3",
"S315FFFFF3C00009AEEAEE00945B480BEE00AEE50009DE",
"S315FFFFF3D0D134E24FAFE52120AFC8E901D13AE200D0",
"S315FFFFF3E02120914E6010CB402100D237E40A6120E5",
"S315FFFFF3F071012210D135E2002120D131410BEE0000",
"S315FFFFF400D226A00B6120D1286312D129601301EC0C",
"S315FFFFF41060330E1461E371016E1C6120611C71FB89",
"S315FFFFF4203E138FF0E4329A2D912DEE002A11912B88",
"S315FFFFF43098272A116080D922CB102800490B000993",
"S315FFFFF4406080CB0128009420490B00096080E40A05",
"S315FFFFF450C9FE2800490B00096080E40AC9EF2800AE",
"S315FFFFF460490B00099112E4042A116080CB0428009E",
"S315FFFFF470490B0009A0510009055502AA008000F1BA",
"S315FFFFF48000F0858086105A00A53A00AAA51A000942",
"S315FFFFF490FFFFF644FFFFF5FAFFFFF852FFFFF849BC",
"S315FFFFF4A0FFFFF847FFFFF850FFFFF840FFFFF8A009",
"S315FFFFF4B0FFFFF8000001FFFF003FFFFFFFFF000018",
"S315FFFFF4C0FFFFF5E0FFFFF891FFFFF890FFFFF8461C",
"S315FFFFF4D0D8386082E402D138410B0E946082699C72",
"S315FFFFF4E006EDD736616D607302EC4119D3346117B0",
"S315FFFFF4F0212B60330E14666760E37001017C261BC8",
"S315FFFFF5000364603301EC621C32908D3B616CD12D3D",
"S315FFFFF510E201212061E371026E1CD12B6110611C98",
"S315FFFFF52071FB3E138FD4E9FF9A3EE405D12260A01B",
"S315FFFFF530D926C9FB2A00410B0009D825490BE44E02",
"S315FFFFF540490BE4546480490B644CD11E61102118AA",
"S315FFFFF550890661809229611C31268901AF45000921",
"S315FFFFF56060A0C9BF2A0061809220611C31208904F7",
"S315FFFFF570941D490BEE00AE1000099419490BEE00DE",
"S315FFFFF580AE0B000931208FC261E3AFC571022310B5",
"S315FFFFF590D1106410D1102140D10C410B644CAFFE4A",
"S315FFFFF5A00009D10EADD5212085800095009600F08C",
"S315FFFFF5B000F10009FFFFF840FFFFF5E0FFFFF8A0AE",
"S315FFFFF5C0FFFFF800FFFFF846FFFFF849FFFFF6448E",
"S315FFFFF5D0FFFFF890FFFFF850FFFFF844FFFFF848E3",
"S315FFFFF5E04408644DE10031428D044F227101611DD4",
"S315FFFFF5F031428BFB4F26000B00094F22E187931CFD",
"S315FFFFF600623021292310D10E93176030C94020089D",
"S315FFFFF610890D21188D08E0009110E001611024107B",
"S315FFFFF6206230E1BF212923104F26000B000971FF2E",
"S315FFFFF630611D21188BE8AFEC000981B481B5000984",
"S315FFFFF6400000EA604F22644C930D6233720461201F",
"S315FFFFF65041118DFA6133710321406020C97F22007A",
"S315FFFFF6604F26000B000981B04F22655C7FF8E7004C",
"S315FFFFF6706053307C034CE209613371D0611C312644",
"S315FFFFF6808D3F613371D060F3071461737101671C9E",
"S315FFFFF690E10737168FEC61F360146110600C4008C9",
"S315FFFFF6A0611C4008301C61F3710261104008611C48",
"S315FFFFF6B04008301C61F3710361104008611C40086C",
"S315FFFFF6C0301C61F3710461104008611C4008301C57",
"S315FFFFF6D061F3710561104008611C4008301C61F33E",
"S315FFFFF6E0710661104008611C4008301C61F3710709",
"S315FFFFF6F061104008611C4008301C7F084F26000B35",
"S315FFFFF7000009AFC071C94F22655C7FFCE7006053FC",
"S315FFFFF710307C034CE209613371D0611C31268D15B4",
"S315FFFFF720613371D060F3071461737101671CE101E7",
"S315FFFFF73037168FEC61F36014600C611040084008C8",
"S315FFFFF740301C600C7F044F26000B0009AFEA71C91E",
"S315FFFFF7504F224F26000B0009000900090009000987",
"S705FFFFF0000C",
NULL
};

const char* ARN44Bbootprogram[] = {
NULL
};

const char* SH27145Bbootprogram[] = {
NULL
};

const char* ARN45Bbootprogram[] = {
NULL
};

const char* H83687Bbootprogram[] = {
"S011000077646C636F6D657830312E61333731",
"S10DF7807A070000EDFC5E00F78A32",
"S113F78A1B9701006DF401006DF501006DF6FA3066",
"S113F79A6AAA0000E990FB317A020000E99168AB99",
"S113F7AA8B017A020000E99268AB8B017A020000AD",
"S113F7BAE99368AB8B017A020000E99468AB8B0188",
"S113F7CA7A020000E99568AB8B017A020000E99697",
"S113F7DA68AB8B017A020000E99768AB8B017A0265",
"S113F7EA0000E99868AB8B017A020000E99968ABDA",
"S113F7FAFB417A020000E99A68AB8B017A020000A5",
"S113F80AE99B68AB8B017A020000E99C68AB8B0127",
"S113F81A7A020000E99D68AB8B017A020000E99E36",
"S113F82A68AB8B017A020000E99F68AB19557A002C",
"S113F83A0000E9A418BB0D5217720A8268AB0B05C3",
"S113F84A7925000143F019557A000000E9B018BB84",
"S113F85A0D5217720A8268AB0B05792500FF43F033",
"S113F86A18AA6AAA0000FFA86A2A0000FFAACA30D6",
"S113F87A6AAA0000FFAAFA0C6AAA0000FFA96A2869",
"S113F88A0000FFE4C8026AA80000FFE46A2A000034",
"S113F89AFFD4CA026AAA0000FFD46A2B0000FFE060",
"S113F8AACB026AAB0000FFE0F8015E00FE6A18AA08",
"S113F8BA6AAA0000E9847A000000E9845E00FE2452",
"S113F8CA6A2A0000E984AA0246DE6A2E0000FF9B27",
"S113F8DACE806AAE0000FF9B6A2A0000FFC2EAF0EB",
"S113F8EACA0A6AAA0000FFC218CC1AA20B027A2218",
"S113F8FA00004E1F43F6F8045E00FE6A0CC85E0060",
"S113F90AFE6A18AA6AAA0000E9847A000000E98457",
"S113F91A5E00FE246A2A0000E984AA0846CC8C0107",
"S113F92AAC0F43C6F8045E00FE6A18AA6AAA00006D",
"S113F93AE9847A000000E9845E00FE246A2A000051",
"S113F94AE984AA0646DE19550D5417740FC07A10B5",
"S113F95A0000E9B05E00FE240C8847F00B05792507",
"S113F96A000143E47A030000E9B0683AAA455870F2",
"S113F97A03BEAA504708FA4268BA580003B27A0288",
"S113F98A0000E9B1682A6AAA0000E9A8F84B5E00F7",
"S113F99AFE6A195540160D5417740FC07A100000E8",
"S113F9AAE9B25E00FE240C8847F00B056A2A0000BF",
"S113F9BAE9A817521D2545DE18AA6AAA0000E9A774",
"S113F9CA19556A2A0000E9A817520B021D2544207A",
"S113F9DA7A010000E9B00D2018BB0D5217720A9281",
"S113F9EA682A08AB0B051D0545F06AAB0000E9A7B8",
"S113F9FA0D5217727A000000E9B06A2B0000E9A7D9",
"S113FA0A78206A2A0000E9B01CAB4708FA43688ADE",
"S113FA1A5800031C7A020000E9B4682B0DB00C806C",
"S113FA2A0C380CB318BB0D0B7A020000E9B5682A2E",
"S113FA3A1752EB0019BB14AB01006BA30000E9A039",
"S113FA4A19556A2A0000E9A817520D2040320D53AD",
"S113FA5A17730D5279120006177278206A2A000069",
"S113FA6AE9B078306AAA0000E80078306AAA00008F",
"S113FA7AE88018AA78306AAA0000E9000B050D028A",
"S113FA8A7912FFFB1D2545C601006B220000E9A07F",
"S113FA9A7A220000DFFF5820024E19226BA20000CE",
"S113FAAAEAB06A2A0000FF90CA406AAA0000FF90DE",
"S113FABA6B220000EAB00B026BA20000EAB018AA9B",
"S113FACA6AAA0000E9A6790000015E00FE10195531",
"S113FADA6A2A0000E9A817527912FFFB1D25442C53",
"S113FAEA7A000000E8800D52177201006B230000AF",
"S113FAFAE9A00AA30A82682A68BA0B056A2A0000DE",
"S113FB0AE9A817527912FFFB1D2545DA6B2100007B",
"S113FB1AEAB018885E00FD5A6A2B0000FF90CB04F5",
"S113FB2A6AAB0000FF90790000045E00FE101955CC",
"S113FB3A6A2A0000E9A817527912FFFB1D255840CA",
"S113FB4A00D67A040000E8800D52177201006B2374",
"S113FB5A0000E9A00AB2EAFCFBFF68AB19220B0217",
"S113FB6A7922000F43F80D53177301006B2200002A",
"S113FB7AE9A00AB269216B220000EAB079220006E0",
"S113FB8A42360FB07A100000E9000FB20AC2682A9E",
"S113FB9A6EFA000F0D120C2A18226E7B000F14BA8B",
"S113FBAA688A0D520B0217720FA37A130000E90038",
"S113FBBA0AC2682A149A68BA0D5217720FA00AC0A8",
"S113FBCA0D130C3B18337A120000E800682A170A4E",
"S113FBDA16BA170A688A0D520B0217720FA30AC3C0",
"S113FBEA7A120000E800682A170A169A0CA917095B",
"S113FBFA68B9680AAAFF4604A9FF4708FA016AAA6B",
"S113FC0A0000E9A60B856A2A0000E9A817527912AE",
"S113FC1AFFFB1D255850FF306A280000FF90E8FBBF",
"S113FC2A6AA80000FF90790000025E00FE106B22B1",
"S113FC3A0000EAB079220006424A19556A2A0000ED",
"S113FC4AE9A817527912FFFB1D25442C7A000000FB",
"S113FC5AE9000D52177201006B230000E9A00AA300",
"S113FC6A0A82682A68BA0B056A2A0000E9A81752A8",
"S113FC7A7912FFFB1D2545DA6B210000EAB0F80171",
"S113FC8A5E00FD5AF84E5E00FE6AF8545E00FE6A93",
"S113FC9A7A020000EAB168285E00FE6A6A2A000055",
"S113FCAAE9A6470E6B220000EAB0792203E758302E",
"S113FCBAFDFE6A2A0000FF90EABF6AAA0000FF90CC",
"S113FCCA790000645E00FE106B220000EAB079221B",
"S113FCDA03E8460AF8F15E00FE6A5800FC68F8F088",
"S113FCEA5E00FE6A5800FC5E01006B240000E9A075",
"S113FCFAF8F25E00FE6A0FC20DA20C2A175217729E",
"S113FD0A0CA85E00FE6A0FC20DA219AA0CA85E0016",
"S113FD1AFE6A0FC20DA00C2A0C820C0817500D0A99",
"S113FD2A0CA85E00FE6A0CC85E00FE6A5800FC1647",
"S113FD3A6A280000E9B06AA80000E9A45E00FE6A25",
"S113FD4A6A2A0000FF9BEA7F6AAA0000FF9B40FE22",
"S113FD5A7A020000FFC0682BEB5568AB18BB6AAB8C",
"S113FD6A0000FFC17D2070206A2A0000FF90CA109B",
"S113FD7A6AAA0000FF9019220B02792201F343F8C0",
"S113FD8A6A2A0000FF90CA016AAA0000FF900C8840",
"S113FD9A471279210006422819220B027922004FC0",
"S113FDAA43F8401C79210006420C19220B027922DD",
"S113FDBA00EF43F8400A19220B027922063F43F85E",
"S113FDCA6A2A0000FF90EAFE6AAA0000FF9019223C",
"S113FDDA0B027922002743F86A2A0000FF90EAEF0F",
"S113FDEA6AAA0000FF9019220B027922002743F81D",
"S113FDFA7A020000FFC07D2072007D207220682BE9",
"S113FE0ACBAA68AB547010101010101019221D02DE",
"S113FE1A44060B021D0245FA54706A2A0000FFAC1C",
"S113FE2AEA876AAA0000FFAC7903EA606A2A00003A",
"S113FE3AFFACEA4046061B030D3346F00D33460475",
"S113FE4A1900401A6A2A0000FFAD688A6A2A00006B",
"S113FE5AFFACEABF6AAA0000FFAC79000001547043",
"S113FE6A6A2A0000FFACEA8047F66AA80000FFABE2",
"S105FE7A5470BE",
"S903F78085",
NULL
};

const char* H8S2345_20MHZbootprogram[] = {
"S01300006838733233343565737365312E61333731",
"S20EFFF4007A0700FFFBFE5EFFF40A2A",
"S214FFF40A01206DF46A38FFFFFED5725018EE7A00B7",
"S214FFF41A00FFFAC418BB0CEA175217720A8268ABC7",
"S214FFF42A8E01AE0143F018EE7A0000FFFAD018BB41",
"S214FFF43A0CEA175217720A8268AB8E01AE3F43F088",
"S214FFF44AFA306AAA00FFFAB0FB317A0200FFFAB175",
"S214FFF45A68AB8B017A0200FFFAB268AB8B017A02BD",
"S214FFF46A00FFFAB368AB8B017A0200FFFAB468AB07",
"S214FFF47A8B017A0200FFFAB568AB8B017A0200FFAE",
"S214FFF48AFAB668AB8B017A0200FFFAB768AB8B0154",
"S214FFF49A7A0200FFFAB868AB8B017A0200FFFAB964",
"S214FFF4AA68ABFB417A0200FFFABA68AB8B017A02B5",
"S214FFF4BA00FFFABB68AB8B017A0200FFFABC68ABA7",
"S214FFF4CA8B017A0200FFFABD68AB8B017A0200FF56",
"S214FFF4DAFABE68AB8B017A0200FFFABF68AB18AABE",
"S214FFF4EA6AAAFFFFFF807A03FFFFFF82683ACA30E5",
"S214FFF4FA68BAFA0F6AAAFFFFFF81F8015EFFF98E64",
"S214FFF50A18AA6AAA00FFFAA47A0000FFFAA45EFF06",
"S214FFF51AF9546A2A00FFFAA4AA0246DEFA083A4211",
"S214FFF52A79025A7F6BA2FFFFFFBE18CC1AA20B0204",
"S214FFF53A7A22000124F743F6F8045EFFF98E0CC818",
"S214FFF54A5EFFF98E18AA6AAA00FFFAA47A0000FFDD",
"S214FFF55AFAA45EFFF9546A2A00FFFAA4AA0846CC60",
"S214FFF56A8C01AC0F43C6F8045EFFF98E18AA6AAA86",
"S214FFF57A00FFFAA47A0000FFFAA45EFFF9546A2A8B",
"S214FFF58A00FFFAA4AA0646DE18EE0CEA17520D2466",
"S214FFF59A17740FC07A1000FFFAD05EFFF9540C8872",
"S214FFF5AA47F08E01AE0143E27A0300FFFAD0683ACB",
"S214FFF5BAAA4558700366AA504708FA4268BA58001E",
"S214FFF5CA035A7A0200FFFAD1682A6AAA00FFFAC823",
"S214FFF5DAF84B5EFFF98E18EE401A0CEA17520D2406",
"S214FFF5EA17740FC07A1000FFFAD25EFFF9540C8820",
"S214FFF5FA47F08E016A2A00FFFAC81CAE45DC18AA35",
"S214FFF60A6AAA00FFFAC718EE6A2A00FFFAC8175254",
"S214FFF61A0B0219001D204C267A0100FFFAD00D2096",
"S214FFF62A18BB0CEA175217720A92682A08AB8E01A1",
"S214FFF63A0CEA17521D024DEA6AAB00FFFAC70CEA3C",
"S214FFF64A175217727A0000FFFAD06A2B00FFFAC722",
"S214FFF65A78206A2A00FFFAD01CAB4708FA43688A62",
"S214FFF66A580002B87A0200FFFAD2682817500C80B0",
"S214FFF67A18880D0819007A0200FFFAD3682A17526B",
"S214FFF68A0D2A19220AA07A0200FFFAD4682B1073F1",
"S214FFF69A107310731073EB0019BB7A0200FFFAD5CA",
"S214FFF6AA682A17520AB014A801006BA000FFFAC016",
"S214FFF6BA18EE6A2A00FFFAC817520D207912FFFBC6",
"S214FFF6CA19331D234C360CEA17520D23177379127A",
"S214FFF6DA000617F278206A2A00FFFAD078306AAA5C",
"S214FFF6EA00FFFB2078306AAA00FFFA808E010CEB37",
"S214FFF6FA17530D027912FFFB1D234DCA01006B2219",
"S214FFF70A00FFFAC07A220001FFFF582001CA18AA92",
"S214FFF71A6AAA00FFFB107FC870606A2A00FFFB1008",
"S214FFF72A8A016AAA00FFFB1018AA6AAA00FFFAC68D",
"S214FFF73A7900000A5EFFF94218EE6A2A00FFFAC845",
"S214FFF74A17527912FFFB19001D204C327A0000FF70",
"S214FFF75AFA800CEA1752177201006B2300FFFAC0F1",
"S214FFF76A0AA30A82682A68BA8E010CEB17536A2A1A",
"S214FFF77A00FFFAC817527912FFFB1D234DD47902F0",
"S214FFF78A5A006BA2FFFFFFBC7902A53A6BA2FFFFE6",
"S214FFF79AFFBC7A0400FFFFC97D4070007900003283",
"S214FFF7AA5EFFF9427FC87000790000AA5EFFF94241",
"S214FFF7BA7FC872007900000A5EFFF9427D40720038",
"S214FFF7CA7900000A5EFFF9427902A51C6BA2FFFFC9",
"S214FFF7DAFFBC7FC87020790000045EFFF94218EE6E",
"S214FFF7EA6A2A00FFFAC817527912FFFB19111D2160",
"S214FFF7FA58C0008C0CED17550D54177401006B2377",
"S214FFF80A00FFFAC00AC3FAFF68BA790000025EFF71",
"S214FFF81AF94201006B2300FFFAC00AC30FC07A1031",
"S214FFF82A00FFFA8069317A1400FFFB20684A170A3C",
"S214FFF83A683B16BA170A688A0B0517F50FD37A13A9",
"S214FFF84A00FFFA807A1500FFFB20685A170A169AF5",
"S214FFF85A0CA9170968B9680AAAFF4604A9FF470848",
"S214FFF86AFA016AAA00FFFAC68E020CEB17536A2A37",
"S214FFF87A00FFFAC817527912FFFB1D2358D0FF74F0",
"S214FFF88A7FC87220790000055EFFF942F84E5EFFD8",
"S214FFF89AF98EF8545EFFF98E6A2800FFFB105EFFAA",
"S214FFF8AAF98E6A2A00FFFAC6470C6A2A00FFFB107F",
"S214FFF8BAAAEF5830FE647FC872606A2A00FFFB1000",
"S214FFF8CAAAF0460AF8F15EFFF98E5800FCBAF8F07D",
"S214FFF8DA5EFFF98E5800FCB001006B2400FFFAC0E9",
"S214FFF8EAF8F25EFFF98E0FC20DA20C2A1752177294",
"S214FFF8FA0CA85EFFF98E0FC20DA219AA0CA85EFF0E",
"S214FFF90AF98E0FC211721172117211720CA85EFF74",
"S214FFF91AF98E0CC85EFFF98E5800FC6C6A2800FF49",
"S214FFF92AFAD06AA800FFFAC45EFFF98E18AA3ACA86",
"S214FFF93A3ACB7FC8726040FE1050105019221D0243",
"S214FFF94A44060B021D0245FA54707A03FFFFFF8432",
"S214FFF95A683AEA8768BA7902EA607C3073604606D4",
"S214FFF96A1B020D2246F40D224604190040146A2A89",
"S214FFF97AFFFFFF85688A6A38FFFFFF847260790097",
"S214FFF98A000154707A03FFFFFF84683AEA8047FA59",
"S214FFF99A6AA8FFFFFF836A38FFFFFF8472705470FE",
"S804FFF40008",
NULL
};

const char* H83687_10MHZbootprogram[] = {
"S011000077646C66616D617230312E61333746",
"S10DF7807A070000EDFC5E00F78A32",
"S113F78A1B9701006DF401006DF501006DF6FA3066",
"S113F79A6AAA0000E990FB317A020000E99168AB99",
"S113F7AA8B017A020000E99268AB8B017A020000AD",
"S113F7BAE99368AB8B017A020000E99468AB8B0188",
"S113F7CA7A020000E99568AB8B017A020000E99697",
"S113F7DA68AB8B017A020000E99768AB8B017A0265",
"S113F7EA0000E99868AB8B017A020000E99968ABDA",
"S113F7FAFB417A020000E99A68AB8B017A020000A5",
"S113F80AE99B68AB8B017A020000E99C68AB8B0127",
"S113F81A7A020000E99D68AB8B017A020000E99E36",
"S113F82A68AB8B017A020000E99F68AB19557A002C",
"S113F83A0000E9A418BB0D5217720A8268AB0B05C3",
"S113F84A7925000143F019557A000000E9B018BB84",
"S113F85A0D5217720A8268AB0B05792500FF43F033",
"S113F86A18AA6AAA0000FFA86A2A0000FFAACA30D6",
"S113F87A6AAA0000FFAAFA076AAA0000FFA96A286E",
"S113F88A0000FFE4C8026AA80000FFE46A2A000034",
"S113F89AFFD4CA026AAA0000FFD46A2B0000FFE060",
"S113F8AACB026AAB0000FFE0F8015E00FE6A18AA08",
"S113F8BA6AAA0000E9847A000000E9845E00FE2452",
"S113F8CA6A2A0000E984AA0246DE6A2E0000FF9B27",
"S113F8DACE806AAE0000FF9B6A2A0000FFC2EAF0EB",
"S113F8EACA0A6AAA0000FFC218CC1AA20B027A2218",
"S113F8FA00004E1F43F6F8045E00FE6A0CC85E0060",
"S113F90AFE6A18AA6AAA0000E9847A000000E98457",
"S113F91A5E00FE246A2A0000E984AA0846CC8C0107",
"S113F92AAC0F43C6F8045E00FE6A18AA6AAA00006D",
"S113F93AE9847A000000E9845E00FE246A2A000051",
"S113F94AE984AA0646DE19550D5417740FC07A10B5",
"S113F95A0000E9B05E00FE240C8847F00B05792507",
"S113F96A000143E47A030000E9B0683AAA455870F2",
"S113F97A03BEAA504708FA4268BA580003B27A0288",
"S113F98A0000E9B1682A6AAA0000E9A8F84B5E00F7",
"S113F99AFE6A195540160D5417740FC07A100000E8",
"S113F9AAE9B25E00FE240C8847F00B056A2A0000BF",
"S113F9BAE9A817521D2545DE18AA6AAA0000E9A774",
"S113F9CA19556A2A0000E9A817520B021D2544207A",
"S113F9DA7A010000E9B00D2018BB0D5217720A9281",
"S113F9EA682A08AB0B051D0545F06AAB0000E9A7B8",
"S113F9FA0D5217727A000000E9B06A2B0000E9A7D9",
"S113FA0A78206A2A0000E9B01CAB4708FA43688ADE",
"S113FA1A5800031C7A020000E9B4682B0DB00C806C",
"S113FA2A0C380CB318BB0D0B7A020000E9B5682A2E",
"S113FA3A1752EB0019BB14AB01006BA30000E9A039",
"S113FA4A19556A2A0000E9A817520D2040320D53AD",
"S113FA5A17730D5279120006177278206A2A000069",
"S113FA6AE9B078306AAA0000E80078306AAA00008F",
"S113FA7AE88018AA78306AAA0000E9000B050D028A",
"S113FA8A7912FFFB1D2545C601006B220000E9A07F",
"S113FA9A7A220000DFFF5820024E19226BA20000CE",
"S113FAAAEAB06A2A0000FF90CA406AAA0000FF90DE",
"S113FABA6B220000EAB00B026BA20000EAB018AA9B",
"S113FACA6AAA0000E9A6790000015E00FE10195531",
"S113FADA6A2A0000E9A817527912FFFB1D25442C53",
"S113FAEA7A000000E8800D52177201006B230000AF",
"S113FAFAE9A00AA30A82682A68BA0B056A2A0000DE",
"S113FB0AE9A817527912FFFB1D2545DA6B2100007B",
"S113FB1AEAB018885E00FD5A6A2B0000FF90CB04F5",
"S113FB2A6AAB0000FF90790000045E00FE101955CC",
"S113FB3A6A2A0000E9A817527912FFFB1D255840CA",
"S113FB4A00D67A040000E8800D52177201006B2374",
"S113FB5A0000E9A00AB2EAFCFBFF68AB19220B0217",
"S113FB6A7922000F43F80D53177301006B2200002A",
"S113FB7AE9A00AB269216B220000EAB079220006E0",
"S113FB8A42360FB07A100000E9000FB20AC2682A9E",
"S113FB9A6EFA000F0D120C2A18226E7B000F14BA8B",
"S113FBAA688A0D520B0217720FA37A130000E90038",
"S113FBBA0AC2682A149A68BA0D5217720FA00AC0A8",
"S113FBCA0D130C3B18337A120000E800682A170A4E",
"S113FBDA16BA170A688A0D520B0217720FA30AC3C0",
"S113FBEA7A120000E800682A170A169A0CA917095B",
"S113FBFA68B9680AAAFF4604A9FF4708FA016AAA6B",
"S113FC0A0000E9A60B856A2A0000E9A817527912AE",
"S113FC1AFFFB1D255850FF306A280000FF90E8FBBF",
"S113FC2A6AA80000FF90790000025E00FE106B22B1",
"S113FC3A0000EAB079220006424A19556A2A0000ED",
"S113FC4AE9A817527912FFFB1D25442C7A000000FB",
"S113FC5AE9000D52177201006B230000E9A00AA300",
"S113FC6A0A82682A68BA0B056A2A0000E9A81752A8",
"S113FC7A7912FFFB1D2545DA6B210000EAB0F80171",
"S113FC8A5E00FD5AF84E5E00FE6AF8545E00FE6A93",
"S113FC9A7A020000EAB168285E00FE6A6A2A000055",
"S113FCAAE9A6470E6B220000EAB0792203E758302E",
"S113FCBAFDFE6A2A0000FF90EABF6AAA0000FF90CC",
"S113FCCA790000645E00FE106B220000EAB079221B",
"S113FCDA03E8460AF8F15E00FE6A5800FC68F8F088",
"S113FCEA5E00FE6A5800FC5E01006B240000E9A075",
"S113FCFAF8F25E00FE6A0FC20DA20C2A175217729E",
"S113FD0A0CA85E00FE6A0FC20DA219AA0CA85E0016",
"S113FD1AFE6A0FC20DA00C2A0C820C0817500D0A99",
"S113FD2A0CA85E00FE6A0CC85E00FE6A5800FC1647",
"S113FD3A6A280000E9B06AA80000E9A45E00FE6A25",
"S113FD4A6A2A0000FF9BEA7F6AAA0000FF9B40FE22",
"S113FD5A7A020000FFC0682BEB5568AB18BB6AAB8C",
"S113FD6A0000FFC17D2070206A2A0000FF90CA109B",
"S113FD7A6AAA0000FF9019220B02792201F343F8C0",
"S113FD8A6A2A0000FF90CA016AAA0000FF900C8840",
"S113FD9A471279210006422819220B027922004FC0",
"S113FDAA43F8401C79210006420C19220B027922DD",
"S113FDBA00EF43F8400A19220B027922063F43F85E",
"S113FDCA6A2A0000FF90EAFE6AAA0000FF9019223C",
"S113FDDA0B027922002743F86A2A0000FF90EAEF0F",
"S113FDEA6AAA0000FF9019220B027922002743F81D",
"S113FDFA7A020000FFC07D2072007D207220682BE9",
"S113FE0ACBAA68AB547010101010101019221D02DE",
"S113FE1A44060B021D0245FA54706A2A0000FFAC1C",
"S113FE2AEA876AAA0000FFAC7903EA606A2A00003A",
"S113FE3AFFACEA4046061B030D3346F00D33460475",
"S113FE4A1900401A6A2A0000FFAD688A6A2A00006B",
"S113FE5AFFACEABF6AAA0000FFAC79000001547043",
"S113FE6A6A2A0000FFACEA8047F66AA80000FFABE2",
"S105FE7A5470BE",
"S903F78085",
NULL
};

const char* H83687_16MHZbootprogram[] = {
"S011000077646C62656E315F30302E61333789",
"S10DF7807A070000EDFC5E00F78A32",
"S113F78A1B9701006DF401006DF501006DF6FA3066",
"S113F79A6AAA0000E990FB317A020000E99168AB99",
"S113F7AA8B017A020000E99268AB8B017A020000AD",
"S113F7BAE99368AB8B017A020000E99468AB8B0188",
"S113F7CA7A020000E99568AB8B017A020000E99697",
"S113F7DA68AB8B017A020000E99768AB8B017A0265",
"S113F7EA0000E99868AB8B017A020000E99968ABDA",
"S113F7FAFB417A020000E99A68AB8B017A020000A5",
"S113F80AE99B68AB8B017A020000E99C68AB8B0127",
"S113F81A7A020000E99D68AB8B017A020000E99E36",
"S113F82A68AB8B017A020000E99F68AB19557A002C",
"S113F83A0000E9A418BB0D5217720A8268AB0B05C3",
"S113F84A7925000143F019557A000000E9B018BB84",
"S113F85A0D5217720A8268AB0B05792500FF43F033",
"S113F86A18AA6AAA0000FFA86A2A0000FFAACA30D6",
"S113F87A6AAA0000FFAAFA0C6AAA0000FFA96A2869",
"S113F88A0000FFE4C8026AA80000FFE46A2A000034",
"S113F89AFFD4CA026AAA0000FFD46A2B0000FFE060",
"S113F8AACB026AAB0000FFE0F8015E00FE6A18AA08",
"S113F8BA6AAA0000E9847A000000E9845E00FE2452",
"S113F8CA6A2A0000E984AA0246DE6A2E0000FF9B27",
"S113F8DACE806AAE0000FF9B6A2A0000FFC2EAF0EB",
"S113F8EACA0A6AAA0000FFC218CC1AA20B027A2218",
"S113F8FA00004E1F43F6F8045E00FE6A0CC85E0060",
"S113F90AFE6A18AA6AAA0000E9847A000000E98457",
"S113F91A5E00FE246A2A0000E984AA0846CC8C0107",
"S113F92AAC0F43C6F8045E00FE6A18AA6AAA00006D",
"S113F93AE9847A000000E9845E00FE246A2A000051",
"S113F94AE984AA0646DE19550D5417740FC07A10B5",
"S113F95A0000E9B05E00FE240C8847F00B05792507",
"S113F96A000143E47A030000E9B0683AAA455870F2",
"S113F97A03BEAA504708FA4268BA580003B27A0288",
"S113F98A0000E9B1682A6AAA0000E9A8F84B5E00F7",
"S113F99AFE6A195540160D5417740FC07A100000E8",
"S113F9AAE9B25E00FE240C8847F00B056A2A0000BF",
"S113F9BAE9A817521D2545DE18AA6AAA0000E9A774",
"S113F9CA19556A2A0000E9A817520B021D2544207A",
"S113F9DA7A010000E9B00D2018BB0D5217720A9281",
"S113F9EA682A08AB0B051D0545F06AAB0000E9A7B8",
"S113F9FA0D5217727A000000E9B06A2B0000E9A7D9",
"S113FA0A78206A2A0000E9B01CAB4708FA43688ADE",
"S113FA1A5800031C7A020000E9B4682B0DB00C806C",
"S113FA2A0C380CB318BB0D0B7A020000E9B5682A2E",
"S113FA3A1752EB0019BB14AB01006BA30000E9A039",
"S113FA4A19556A2A0000E9A817520D2040320D53AD",
"S113FA5A17730D5279120006177278206A2A000069",
"S113FA6AE9B078306AAA0000E80078306AAA00008F",
"S113FA7AE88018AA78306AAA0000E9000B050D028A",
"S113FA8A7912FFFB1D2545C601006B220000E9A07F",
"S113FA9A7A220000DFFF5820024E19226BA20000CE",
"S113FAAAEAB06A2A0000FF90CA406AAA0000FF90DE",
"S113FABA6B220000EAB00B026BA20000EAB018AA9B",
"S113FACA6AAA0000E9A6790000015E00FE10195531",
"S113FADA6A2A0000E9A817527912FFFB1D25442C53",
"S113FAEA7A000000E8800D52177201006B230000AF",
"S113FAFAE9A00AA30A82682A68BA0B056A2A0000DE",
"S113FB0AE9A817527912FFFB1D2545DA6B2100007B",
"S113FB1AEAB018885E00FD5A6A2B0000FF90CB04F5",
"S113FB2A6AAB0000FF90790000045E00FE101955CC",
"S113FB3A6A2A0000E9A817527912FFFB1D255840CA",
"S113FB4A00D67A040000E8800D52177201006B2374",
"S113FB5A0000E9A00AB2EAFCFBFF68AB19220B0217",
"S113FB6A7922000F43F80D53177301006B2200002A",
"S113FB7AE9A00AB269216B220000EAB079220006E0",
"S113FB8A42360FB07A100000E9000FB20AC2682A9E",
"S113FB9A6EFA000F0D120C2A18226E7B000F14BA8B",
"S113FBAA688A0D520B0217720FA37A130000E90038",
"S113FBBA0AC2682A149A68BA0D5217720FA00AC0A8",
"S113FBCA0D130C3B18337A120000E800682A170A4E",
"S113FBDA16BA170A688A0D520B0217720FA30AC3C0",
"S113FBEA7A120000E800682A170A169A0CA917095B",
"S113FBFA68B9680AAAFF4604A9FF4708FA016AAA6B",
"S113FC0A0000E9A60B856A2A0000E9A817527912AE",
"S113FC1AFFFB1D255850FF306A280000FF90E8FBBF",
"S113FC2A6AA80000FF90790000025E00FE106B22B1",
"S113FC3A0000EAB079220006424A19556A2A0000ED",
"S113FC4AE9A817527912FFFB1D25442C7A000000FB",
"S113FC5AE9000D52177201006B230000E9A00AA300",
"S113FC6A0A82682A68BA0B056A2A0000E9A81752A8",
"S113FC7A7912FFFB1D2545DA6B210000EAB0F80171",
"S113FC8A5E00FD5AF84E5E00FE6AF8545E00FE6A93",
"S113FC9A7A020000EAB168285E00FE6A6A2A000055",
"S113FCAAE9A6470E6B220000EAB0792203E758302E",
"S113FCBAFDFE6A2A0000FF90EABF6AAA0000FF90CC",
"S113FCCA790000645E00FE106B220000EAB079221B",
"S113FCDA03E8460AF8F15E00FE6A5800FC68F8F088",
"S113FCEA5E00FE6A5800FC5E01006B240000E9A075",
"S113FCFAF8F25E00FE6A0FC20DA20C2A175217729E",
"S113FD0A0CA85E00FE6A0FC20DA219AA0CA85E0016",
"S113FD1AFE6A0FC20DA00C2A0C820C0817500D0A99",
"S113FD2A0CA85E00FE6A0CC85E00FE6A5800FC1647",
"S113FD3A6A280000E9B06AA80000E9A45E00FE6A25",
"S113FD4A6A2A0000FF9BEA7F6AAA0000FF9B40FE22",
"S113FD5A7A020000FFC0682BEB5568AB18BB6AAB8C",
"S113FD6A0000FFC17D2070206A2A0000FF90CA109B",
"S113FD7A6AAA0000FF9019220B02792201F343F8C0",
"S113FD8A6A2A0000FF90CA016AAA0000FF900C8840",
"S113FD9A471279210006422819220B027922004FC0",
"S113FDAA43F8401C79210006420C19220B027922DD",
"S113FDBA00EF43F8400A19220B027922063F43F85E",
"S113FDCA6A2A0000FF90EAFE6AAA0000FF9019223C",
"S113FDDA0B027922002743F86A2A0000FF90EAEF0F",
"S113FDEA6AAA0000FF9019220B027922002743F81D",
"S113FDFA7A020000FFC07D2072007D207220682BE9",
"S113FE0ACBAA68AB547010101010101019221D02DE",
"S113FE1A44060B021D0245FA54706A2A0000FFAC1C",
"S113FE2AEA876AAA0000FFAC7903EA606A2A00003A",
"S113FE3AFFACEA4046061B030D3346F00D33460475",
"S113FE4A1900401A6A2A0000FFAD688A6A2A00006B",
"S113FE5AFFACEABF6AAA0000FFAC79000001547043",
"S113FE6A6A2A0000FFACEA8047F66AA80000FFABE2",
"S105FE7A5470BE",
"S903F78085",
NULL
};

const char* H83687_16MHZ_BEN10_bootprogram[] = {
"S018000077646C62656E315F30305F6F6670756D702E6133378C",
"S10DF7807A070000EDFC5E00F78A32",
"S113F78A1B9701006DF401006DF501006DF6FA8016",
"S113F79A6AAA0000FFE96A280000FFD914A86AA827",
"S113F7AA0000FFD9FA306AAA0000E990FB317A0214",
"S113F7BA0000E99168AB8B017A020000E99268AB18",
"S113F7CA8B017A020000E99368AB8B017A0200008C",
"S113F7DAE99468AB8B017A020000E99568AB8B0166",
"S113F7EA7A020000E99668AB8B017A020000E99775",
"S113F7FA68AB8B017A020000E99868AB8B017A0244",
"S113F80A0000E99968ABFB417A020000E99A68AB07",
"S113F81A8B017A020000E99B68AB8B017A02000033",
"S113F82AE99C68AB8B017A020000E99D68AB8B0105",
"S113F83A7A020000E99E68AB8B017A020000E99F14",
"S113F84A68AB19557A000000E9A418BB0D52177267",
"S113F85A0A8268AB0B057925000143F019557A0031",
"S113F86A0000E9B018BB0D5217720A8268AB0B0587",
"S113F87A792500FF43F018AA6AAA0000FFA86A2A99",
"S113F88A0000FFAACA306AAA0000FFAAFA0C6AAAF0",
"S113F89A0000FFA96A2A0000FFE4CA026AAA00005B",
"S113F8AAFFE46A2B0000FFD4CB026AAB0000FFD44A",
"S113F8BA6A2E0000FFE0CE026AAE0000FFE0F80103",
"S113F8CA5E00FE8018AA6AAA0000E9847A00000091",
"S113F8DAE9845E00FE3A6A2A0000E984AA0246DE46",
"S113F8EA6A280000FF9BC8806AA80000FF9B6A2A56",
"S113F8FA0000FFC2EAF0CA0A6AAA0000FFC218CCD2",
"S113F90A1AA20B027A2200004E1F43F6F8045E0084",
"S113F91AFE800CC85E00FE8018AA6AAA0000E98468",
"S113F92A7A000000E9845E00FE3A6A2A0000E9844B",
"S113F93AAA0846CC8C01AC0F43C6F8045E00FE80CC",
"S113F94A18AA6AAA0000E9847A000000E9845E0021",
"S113F95AFE3A6A2A0000E984AA0646DE19550D54BD",
"S113F96A17740FC07A100000E9B05E00FE3A0C88E2",
"S113F97A47F00B057925000143E47A030000E9B056",
"S113F98A683AAA45587003BEAA504708FA4268BAA8",
"S113F99A580003B27A020000E9B1682A6AAA000090",
"S113F9AAE9A8F84B5E00FE80195540160D541774E9",
"S113F9BA0FC07A100000E9B25E00FE3A0C8847F0E4",
"S113F9CA0B056A2A0000E9A817521D2545DE18AA64",
"S113F9DA6AAA0000E9A719556A2A0000E9A8175279",
"S113F9EA0B021D2544207A010000E9B00D2018BB42",
"S113F9FA0D5217720A92682A08AB0B051D0545F0C9",
"S113FA0A6AAB0000E9A70D5217727A000000E9B048",
"S113FA1A6A2B0000E9A778206A2A0000E9B01CAB27",
"S113FA2A4708FA43688A5800031C7A020000E9B4BA",
"S113FA3A682B0DB60CE60C3E0CB318BB0D6B7A02A0",
"S113FA4A0000E9B5682A1752EB0019BB14AB010090",
"S113FA5A6BA30000E9A019556A2A0000E9A8175205",
"S113FA6A0D2040320D5317730D5279120006177286",
"S113FA7A78206A2A0000E9B078306AAA0000E8000F",
"S113FA8A78306AAA0000E88018AA78306AAA0000C6",
"S113FA9AE9000B050D027912FFFB1D2545C601007D",
"S113FAAA6B220000E9A07A220000DFFF5820024EF0",
"S113FABA19226BA20000EAB06A280000FF90C8402D",
"S113FACA6AA80000FF906B220000EAB00B026BA246",
"S113FADA0000EAB018AA6AAA0000E9A6790000019F",
"S113FAEA5E00FE2619556A2A0000E9A817527912FF",
"S113FAFAFFFB1D25442C7A000000E8800D52177282",
"S113FB0A01006B230000E9A00AA30A82682A68BAE2",
"S113FB1A0B056A2A0000E9A817527912FFFB1D2572",
"S113FB2A45DA6B210000EAB018885E00FD706A2A83",
"S113FB3A0000FF90CA046AAA0000FF90790000043A",
"S113FB4A5E00FE2619556A2A0000E9A8175279129E",
"S113FB5AFFFB1D25584000D67A040000E8800D52A8",
"S113FB6A177201006B230000E9A00AB2EAFCFBFF4A",
"S113FB7A68AB19220B027922000F43F80D5317734D",
"S113FB8A01006B220000E9A00AB269216B2200007D",
"S113FB9AEAB07922000642360FB07A100000E90072",
"S113FBAA0FB20AC2682A6EFA000F0D120C2A182222",
"S113FBBA6E7E000F14EA688A0D520B0217720FA3A5",
"S113FBCA7A130000E9000AC2682A149A68BA0D5224",
"S113FBDA17720FA00AC00D130C3B18337A120000D7",
"S113FBEAE800682A170A16BA170A688A0D520B021D",
"S113FBFA17720FA30AC37A120000E800682A170AC8",
"S113FC0A169A0CA9170968B9680AAAFF4604A9FF33",
"S113FC1A4708FA016AAA0000E9A60B856A2A0000C5",
"S113FC2AE9A817527912FFFB1D255850FF306A289C",
"S113FC3A0000FF90E8FB6AA80000FF907900000228",
"S113FC4A5E00FE266B220000EAB079220006424AD0",
"S113FC5A19556A2A0000E9A817527912FFFB1D25D3",
"S113FC6A442C7A000000E9000D52177201006B233C",
"S113FC7A0000E9A00AA30A82682A68BA0B056A2A5C",
"S113FC8A0000E9A817527912FFFB1D2545DA6B21FA",
"S113FC9A0000EAB0F8015E00FD70F84E5E00FE80D6",
"S113FCAAF8545E00FE807A020000EAB168285E0019",
"S113FCBAFE806A2A0000E9A6470E6B220000EAB019",
"S113FCCA792203E75830FDFE6A2A0000FF90EABF52",
"S113FCDA6AAA0000FF90790000645E00FE266B2287",
"S113FCEA0000EAB0792203E8460AF8F15E00FE80D1",
"S113FCFA5800FC68F8F05E00FE805800FC5E0100C3",
"S113FD0A6B240000E9A0F8F25E00FE800FC20DA287",
"S113FD1A0C2A175217720CA85E00FE800FC20DA29D",
"S113FD2A19AA0CA85E00FE800FC20DA00C2A0C8230",
"S113FD3A0C0817500D0A0CA85E00FE800CC85E0061",
"S113FD4AFE805800FC166A280000E9B06AA8000080",
"S113FD5AE9A45E00FE806A2A0000FF9BEA7F6AAA81",
"S113FD6A0000FF9B40FE7A020000FFC0682BEB559F",
"S113FD7A68AB18BB6AAB0000FFC17D2070206A2AF9",
"S113FD8A0000FF90CA106AAA0000FF9019220B0211",
"S113FD9A792201F343F86A2A0000FF90CA016AAA89",
"S113FDAA0000FF900C884712792100064228192284",
"S113FDBA0B027922004F43F8401C79210006420CB9",
"S113FDCA19220B02792200EF43F8400A19220B0286",
"S113FDDA7922063F43F86A2A0000FF90EAFE6AAADB",
"S113FDEA0000FF9019220B027922002743F86A2A9D",
"S113FDFA0000FF90EAEF6AAA0000FF9019220B02A2",
"S113FE0A7922002743F87A020000FFC07D2072009D",
"S113FE1A7D207220682BCBAA68AB54701010101086",
"S113FE2A101019221D0244060B021D0245FA5470D1",
"S113FE3A6A2A0000FFACEA876AAA0000FFAC7903C9",
"S113FE4AEA606A2A0000FFACEA4046061B030D3347",
"S113FE5A46F00D3346041900401A6A2A0000FFAD21",
"S113FE6A688A6A2A0000FFACEABF6AAA0000FFACEB",
"S113FE7A7900000154706A2A0000FFACEA8047F650",
"S10BFE8A6AA80000FFAB5470EC",
"S903F78085",
NULL
};

const char* H83048FONE_16MHZbootprogram[] = {
"S0130000696E647574746976616B30302E61333750",
"S20CFFF51040FE6266333034381A",
"S20EFFF5187A0700FFF10C5EFFF522F4",
"S214FFF52201006DF401006DF501006DF6FA306AAA6E",
"S214FFF53200FFFDA0FB317A0200FFFDA168AB8B0145",
"S214FFF5427A0200FFFDA268AB8B017A0200FFFDA3E1",
"S214FFF55268AB8B017A0200FFFDA468AB8B017A02CF",
"S214FFF56200FFFDA568AB8B017A0200FFFDA668AB24",
"S214FFF5728B017A0200FFFDA768AB8B017A0200FFC0",
"S214FFF582FDA868AB8B017A0200FFFDA968ABFB41C1",
"S214FFF5927A0200FFFDAA68AB8B017A0200FFFDAB81",
"S214FFF5A268AB8B017A0200FFFDAC68AB8B017A0277",
"S214FFF5B200FFFDAD68AB8B017A0200FFFDAE68ABC4",
"S214FFF5C28B017A0200FFFDAF68AB19557A0000FF88",
"S214FFF5D2FDB418BB0D5217720A8268AB0B0579256C",
"S214FFF5E2000143F019557A0000FFFDC018BB0D520B",
"S214FFF5F217720A8268AB0B05792500FF43F018AA3B",
"S214FFF6023AB82ABACA303ABAFA0C3AB9F8015EFFE1",
"S214FFF612FB6618AA6AAA00FFFD947A0000FFFD9413",
"S214FFF6225EFFFB3A6A2A00FFFD94AA0246DE7902D3",
"S214FFF6325A7F6B82FFAA18CC1AA20B027A2200000C",
"S214FFF6424E1F43F6F8045EFFFB660CC85EFFFB66C2",
"S214FFF65218AA6AAA00FFFD947A0000FFFD945EFFD7",
"S214FFF662FB3A6A2A00FFFD94AA0846CC8C01AC0F2F",
"S214FFF67243C6F8045EFFFB6618AA6AAA00FFFD945B",
"S214FFF6827A0000FFFD945EFFFB3A6A2A00FFFD94B4",
"S214FFF692AA0646DE19550D5417740FC07A1000FFDE",
"S214FFF6A2FDC05EFFFB3A0C8847F00B05792500018B",
"S214FFF6B243E47A0300FFFDC0683AAA45587003BACE",
"S214FFF6C2AA504708FA4268BA580003AE7A0200FF09",
"S214FFF6D2FDC1682A6AAA00FFFDB8F84B5EFFFB660B",
"S214FFF6E2195540160D5417740FC07A1000FFFDC24D",
"S214FFF6F25EFFFB3A0C8847F00B056A2A00FFFDB84F",
"S214FFF70217521D2545DE18AA6AAA00FFFDB719552E",
"S214FFF7126A2A00FFFDB817520B021D2544207A0104",
"S214FFF72200FFFDC00D2018BB0D5217720A92682A01",
"S214FFF73208AB0B051D0545F06AAB00FFFDB70D5282",
"S214FFF74217727A0000FFFDC06A2B00FFFDB7782014",
"S214FFF7526A2A00FFFDC01CAB4708FA43688A5800B6",
"S214FFF76203187A0200FFFDC2682817500C8018881B",
"S214FFF7720D0819007A0200FFFDC3682A17520D2AE8",
"S214FFF78219220AA07A0200FFFDC4682B0DB40CC42E",
"S214FFF7920C3C0CB318BB0D4BEB0019BB7A0200FFF7",
"S214FFF7A2FDC5682A17520AB014A801006BA000FF15",
"S214FFF7B2FDB019556A2A00FFFDB817520D204032D8",
"S214FFF7C20D5317730D5279120006177278206A2AA4",
"S214FFF7D200FFFDC078306AAA00FFFC1078306AAAE4",
"S214FFF7E200FFFC9018AA78306AAA00FFFD100B05EE",
"S214FFF7F20D027912FFFB1D2545C601006B2200FF95",
"S214FFF802FDB07A220001FFFF5820022619226BA2C2",
"S214FFF81200FFFEC07F4070606B2200FFFEC00B023F",
"S214FFF8226BA200FFFEC018AA6AAA00FFFDB6790007",
"S214FFF83200015EFFFB2619556A2A00FFFDB8175224",
"S214FFF8427912FFFB1D25442C7A0000FFFC900D5217",
"S214FFF852177201006B2300FFFDB00AA30A82682A13",
"S214FFF86268BA0B056A2A00FFFDB817527912FFFB2A",
"S214FFF8721D2545DA6B2100FFFEC018885EFFFA8E53",
"S214FFF8827F407020790000045EFFFB2619556A2A26",
"S214FFF89200FFFDB817527912FFFB1D25584000C620",
"S214FFF8A27A0600FFFC900D54177401006B2300FFCD",
"S214FFF8B2FDB00AC3FAFF68BA790000025EFFFB26B4",
"S214FFF8C201006B2200FFFDB00AC269216B2200FF16",
"S214FFF8D2FEC079220006422E0FC07A1000FFFD10EE",
"S214FFF8E20FC20AE2682B0D120C2A182214BA688A73",
"S214FFF8F20D520B0217720FA37A1300FFFD100AE2D6",
"S214FFF902682A149A68BA0D5217720FA00AE00D13EE",
"S214FFF9120C3B183378206A2A00FFFC10170A16BA27",
"S214FFF922170A688A0D520B0217720FA30AE3782092",
"S214FFF9326A2A00FFFC10170A169A0CA9170968B95B",
"S214FFF942680AAAFF4604A9FF4708FA016AAA00FF47",
"S214FFF952FDB60B856A2A00FFFDB817527912FFFB28",
"S214FFF9621D255850FF407F407220790000025EFF3F",
"S214FFF972FB266B2200FFFEC079220006424A19557B",
"S214FFF9826A2A00FFFDB817527912FFFB1D25442C89",
"S214FFF9927A0000FFFD100D52177201006B2300FF65",
"S214FFF9A2FDB00AA30A82682A68BA0B056A2A00FF14",
"S214FFF9B2FDB817527912FFFB1D2545DA6B2100FFB2",
"S214FFF9C2FEC0F8015EFFFA8EF84E5EFFFB66F85445",
"S214FFF9D25EFFFB667A0200FFFEC168285EFFFB66DB",
"S214FFF9E26A2A00FFFDB6470E6B2200FFFEC0792291",
"S214FFF9F203E75830FE227A0200FFFF40682BEB40F7",
"S214FFFA027D2072606828148B68AB790000645EFF05",
"S214FFFA12FB266B2200FFFEC0792203E8460AF8F1B6",
"S214FFFA225EFFFB665800FC6CF8F05EFFFB66580054",
"S214FFFA32FC6201006B2400FFFDB0F8F25EFFFB667E",
"S214FFFA420FC20DA20C2A175217720CA85EFFFB6696",
"S214FFFA520FC20DA219AA0CA85EFFFB660FC20DA06D",
"S214FFFA620C2A0C820C0817500D0A0CA85EFFFB66C8",
"S214FFFA720CC85EFFFB665800FC1A6A2800FFFDC032",
"S214FFFA826AA800FFFDB45EFFFB6640FE01006DF450",
"S214FFFA9201006DF501006DF60C8D0D167A0300FF61",
"S214FFFAA2FFA879025A0069B27902A53A69B27A04C6",
"S214FFFAB200FFFF407D407040790000325EFFFB266C",
"S214FFFAC27D4070000CDD4710792600064222790041",
"S214FFFAD2000A5EFFFB26401879260006420A7900D6",
"S214FFFAE2001E5EFFFB264008790000C85EFFFB266D",
"S214FFFAF27A0400FFFF407D407200790000055EFF3A",
"S214FFFB02FB267D407240790000055EFFFB267902E8",
"S214FFFB12A51C6B82FFA801006D7601006D750100C2",
"S214FFFB226D74547010101010101019221D02440626",
"S214FFFB320B021D0245FA54702ABCEA873ABC7902C8",
"S214FFFB42EA607EBC736046061B020D2246F40D2257",
"S214FFFB5246041900400C2ABD688A7FBC7260790091",
"S214FFFB62000154702ABCEA8047FA38BB7FBC727029",
"S206FFFB725470C9",
"S804FFF518EF",
NULL
};

const char* H836064_16MHZbootprogram[] = {
"S01000007A64726976655F30302E613337A3",
"S10DF7807A070000FF7C5E00F78AA0",
"S113F78A1B9701006DF401006DF501006DF6195522",
"S113F79A7A000000FEB00D5217720A820CDB8B301D",
"S113F7AA68AB0B057925000943EC19557A0000006A",
"S113F7BAFEB00D527912000A17720A820CDB8B41D1",
"S113F7CA68AB0B057925000543E819557A00000052",
"S113F7DAFEC418BB0D5217720A8268AB0B05792551",
"S113F7EA000143F019557A000000FED018BB0D52EF",
"S113F7FA17720A8268AB0B057925008743F018AAA9",
"S113F80A6AAA0000FFA86A2A0000FFAACA306AAAE4",
"S113F81A0000FFAAFA0C6AAA0000FFA96A280000DD",
"S113F82AFFE4C8026AA80000FFE46A2A0000FFD4C1",
"S113F83ACA026AAA0000FFD46A2B0000FFE0CB02C6",
"S113F84A6AAB0000FFE0F8015E00FDFE18AA6AAA8E",
"S113F85A0000FEA87A000000FEA85E00FDB86A2A2D",
"S113F86A0000FEA8AA0246DE6A280000FF9BC880A0",
"S113F87A6AA80000FF9B6A2A0000FFC2EAF0CA0ACB",
"S113F88A6AAA0000FFC218CC1AA20B027A2200004C",
"S113F89A4E1F43F6F8045E00FDFE0CC85E00FDFE32",
"S113F8AA18AA6AAA0000FEA87A000000FEA85E0050",
"S113F8BAFDB86A2A0000FEA8AA0846CC8C01AC0F3F",
"S113F8CA43C6F8045E00FDFE18AA6AAA0000FEA850",
"S113F8DA7A000000FEA85E00FDB86A2A0000FEA8AD",
"S113F8EAAA0646DE19550D5417740FC07A10000083",
"S113F8FAFED05E00FDB80C8847F00B05792500019F",
"S113F90A43E47A030000FED0683AAA45587003B467",
"S113F91AAA504708FA4268BA580003A87A020000B3",
"S113F92AFED1682A6AAA0000FEC8F84B5E00FDFEF2",
"S113F93A195540160D5417740FC07A100000FED2E0",
"S113F94A5E00FDB80C8847F00B056A2A0000FEC861",
"S113F95A17521D2545DE18AA6AAA0000FEC71955C2",
"S113F96A6A2A0000FEC817520B021D2544207A0198",
"S113F97A0000FED00D2018BB0D5217720A92682A95",
"S113F98A08AB0B051D0545F06AAB0000FEC70D5216",
"S113F99A17727A000000FED06A2B0000FEC7782096",
"S113F9AA6A2A0000FED01CAB4708FA43688A58004A",
"S113F9BA03127A020000FED4682B0DB00C800C38B6",
"S113F9CA0CB318BB0D0B7A020000FED5682A175235",
"S113F9DAEB0019BB14AB01006BA30000FEC07A0252",
"S113F9EA0000FED601006BA20000FEA019556A2A87",
"S113F9FA0000FEC817527912FFFB1D2544187A012C",
"S113FA0A0000FE2018880D230D5217720A9268A866",
"S113FA1A0B051D3545F201006B220000FEC07A2257",
"S113FA2A00007FFE5820025419226BA20000FF58DE",
"S113FA3A6A2A0000FF90CA406AAA0000FF906B225B",
"S113FA4A0000FF580B026BA20000FF5818AA6AAA0A",
"S113FA5A0000FEC6790000015E00FDA41955401E8F",
"S113FA6A0D50177001006B230000FEC00A830100C9",
"S113FA7A6B220000FEA00A82682A68BA0B056A2A69",
"S113FA8A0000FEC817527912FFFB1D2545D26B21CF",
"S113FA9A0000FF5818885E00FCEE6A2B0000FF90F5",
"S113FAAACB046AAB0000FF90790000045E00FDA459",
"S113FABA19556A2A0000FEC817527912FFFB1D2540",
"S113FACA584000E87A060000FE200D521772010021",
"S113FADA6B230000FEC00AB2EAFCFBFF68AB1922E2",
"S113FAEA0B027922000F43F80D53177301006B229E",
"S113FAFA0000FEC00AB269246B220000FF58792272",
"S113FB0A000642360FB10AE101006B200000FEA094",
"S113FB1A0F820AB2682A6EFA000F0D420C2A1822C2",
"S113FB2A6E7B000F14BA689A0D520B0217720FA358",
"S113FB3A0AE30AA0680A14CA68BA0D5117710100C7",
"S113FB4A6B230000FEA00A930D400C081800683AC3",
"S113FB5A170A168A170A68BA0D520B020D20177073",
"S113FB6A01006B230000FEA00A83683A170A16CA2A",
"S113FB7A170A68BA01006B230000FEA00FB20A92AA",
"S113FB8A682AAAFF460A0FB20A82682AAAFF470805",
"S113FB9AFA016AAA0000FEC60B856A2A0000FEC89A",
"S113FBAA17527912FFFB1D255850FF1E6A2B0000BD",
"S113FBBAFF90EBFB6AAB0000FF90790000025E0045",
"S113FBCAFDA46B220000FF5879220006424A195507",
"S113FBDA6A2A0000FEC817527912FFFB1D25442C1D",
"S113FBEA7A000000FE200D52177201006B230000F8",
"S113FBFAFEC00AA30A82682A68BA0B056A2A0000A8",
"S113FC0AFEC817527912FFFB1D2545DA6B21000045",
"S113FC1AFF58F8015E00FCEEF84E5E00FDFEF85453",
"S113FC2A5E00FDFE7A020000FF5968285E00FDFEB0",
"S113FC3A6A2A0000FEC6470E6B220000FF5879228A",
"S113FC4A03E75830FDF86A280000FF90E8BF6AA865",
"S113FC5A0000FF90790000645E00FDA46B2200009E",
"S113FC6AFF58792203E8460AF8F15E00FDFE5800BF",
"S113FC7AFC72F8F05E00FDFE5800FC6801006B247B",
"S113FC8A0000FEC0F8F25E00FDFE0FC20DA20C2AAF",
"S113FC9A175217720CA85E00FDFE0FC20DA219AA14",
"S113FCAA0CA85E00FDFE0FC20DA30C2A0CB20C3B7D",
"S113FCBA17530D3A0CA85E00FDFE0CC85E00FDFE4B",
"S113FCCA5800FC206A280000FED06AA80000FEC47E",
"S113FCDA5E00FDFE6A280000FF9BE87F6AA8000018",
"S113FCEAFF9B40FE7A020000FFC0682BEB5568AB0D",
"S113FCFA18BB6AAB0000FFC17D2070206A2A00008D",
"S113FD0AFF90CA106AAA0000FF9019220B027922F6",
"S113FD1A01F343F86A2A0000FF90CA016AAA0000A4",
"S113FD2AFF900C88471279210006422819220B02F7",
"S113FD3A7922004F43F8401C79210006420C19220B",
"S113FD4A0B02792200EF43F8400A19220B027922A6",
"S113FD5A063F43F86A2A0000FF90EAFE6AAA0000F6",
"S113FD6AFF9019220B027922002743F86A2A00001D",
"S113FD7AFF90EAEF6AAA0000FF9019220B02792287",
"S113FD8A002743F87A020000FFC07D2072007D201C",
"S113FD9A7220682BCBAA68AB547010101010101084",
"S113FDAA19221D0244060B021D0245FA54706A2ADE",
"S113FDBA0000FFACEA876AAA0000FFAC7903EA6094",
"S113FDCA6A2A0000FFACEA4046061B030D3346F0DC",
"S113FDDA0D3346041900401A6A2A0000FFAD688AE6",
"S113FDEA6A2A0000FFACEABF6AAA0000FFAC7900E5",
"S113FDFA000154706A2A0000FFACEA8047F66AA838",
"S109FE0A0000FFAB547080",
"S903F78085",
NULL
};

static const char** bootprogram[] = {
H83048bootprogram,                      // 0
H8S2345bootprogram,                     // 1
H8S2345Z24Ebootprogram,                 // 2
SH27044bootprogram,                     // 3
SH27044Fbootprogram,                    // 4
ARN44Bbootprogram,			// 5
SH27145Bbootprogram,			// 6
ARN45Bbootprogram,			// 7
H83687Bbootprogram,			// 8
H8S2345_20MHZbootprogram,		// 9
H83687_10MHZbootprogram,		// 10
H83687_16MHZbootprogram,                // 11
H83687_16MHZ_BEN10_bootprogram,         // 12
H83048FONE_16MHZbootprogram,            // 13
H836064_16MHZbootprogram,		// 14
NULL					// END
};

static unsigned short N_SECTS[] = {
	16,			// 0
	16,			// 1
        16,			// 2
        16,			// 3
        32,			// 4
        0,			// 5
        0,			// 6
        0,			// 7
        16,			// 8
        16,			// 9
        16,			// 10
        16,			// 11
        16,			// 12
        16,			// 13
        16,			// 14
	0};			// END
unsigned short N_SECTORS;

//static CpuTarget_t convtocpu(char* cpu);

//static bool AutoBaudRate(char* portname);
//static bool DownloadBootProgram(char* portname,QStrList* BootProgram);
//static bool DownloadTargetProgram(char* portname,QStrList* TargetProgram);
//static bool ListenAndAnswerToEcu(arnSerialInterface* PortaComm,unsigned char LstCmd,unsigned char AswCmd);
//static bool ListenAndAnswerToEcuForErasingSectors(arnSerialInterface* PortaComm,unsigned char LstCmd,unsigned char AswCmd,unsigned char* Sect);



//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------
//---
//---  APPOGGIO
//---
//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------

typedef enum{HEADER,DATA,FINAL,NONE} TipoRecord;
typedef struct _InfoRecord {
                           TipoRecord Tipo;
                           unsigned char NumOfByte;
                           } InfoRecord;



class Record
{
private:
protected:
	TipoRecord Tipo;
	unsigned char NumOfByte;
	unsigned long BaseAddr;
	unsigned char NumOfData;
	unsigned char *Data;
	unsigned char CheckSum;
public:
	Record(const QString& Str);
	Record(void);
	~Record(void);
	Record& operator =(const Record& R);
	TipoRecord GetTipo(void) {return Tipo;}
	unsigned char GetData(unsigned char i) {return Data[i];}
	unsigned char GetNumOfData(void) {return NumOfData;}
	bool SendRecord(arnSerialInterface *HPt);
	bool SendData(arnSerialInterface *HPt);
};



typedef enum _targetdatasize_t {_8bit,_16bit,_32bit,_nbiterr} targetdatasize_t;
typedef enum _targetpagesize_t {_tps32,_tps128,_tps256,_tpserr} targetpagesize_t;
typedef struct _quantum8bit_t {
      //_quantum8bit_t* next;
      unsigned long BaseAddr;
      unsigned long Size;
      unsigned char* Data;
      unsigned long ptr;
      } quantum8bit_t;
#define PAGESIZE32     32
typedef struct _page32bytes {
      unsigned long Addr;
      unsigned long ntwrite;
      unsigned char Data[PAGESIZE32];
      } page32bytes;
#define PAGESIZE128     128
typedef struct _page128bytes {
      unsigned long Addr;
      unsigned long ntwrite;
      unsigned char Data[PAGESIZE128];
      } page128bytes;
#define PAGESIZE256     256
typedef struct _page256bytes {
	  unsigned long Addr;
	  unsigned long ntwrite;
	  unsigned char Data[PAGESIZE256];
	  } page256bytes;
class RecordArricchito : public Record {
   private:
   protected:
   public:
   RecordArricchito(const QString& Str) : Record(Str) {;}
   RecordArricchito(void) : Record() {;}
   ~RecordArricchito(void) {;}
   unsigned long GetBaseAddr(void) {return BaseAddr;}
   };

class DataStream {
   private:
      #define PRGOKPAGE	((unsigned char)0xF0)
      #define PRGNOTPAGE	((unsigned char)0xF1)
      #define ADDROUTOFRANGE	((unsigned char)0xF2)

   protected:
      targetdatasize_t targetdatasize;
      targetpagesize_t targetpagesize;
      unsigned short numofquantum;
      quantum8bit_t** Block8bit;

   public:
     DataStream(targetdatasize_t datasize = _8bit, targetpagesize_t pagesize = _tps32);
     virtual ~DataStream(void);
     virtual bool ConvFromRecordQuantum8bit(Record* RecArr,int RecArrSize,
                unsigned short numofquan,
                unsigned long* startaddr_arr,
                unsigned long* size_arr) = 0;
	 virtual bool IsDummyPage(unsigned long Num) = 0;
     virtual bool SendPage(arnSerialInterface *HPt,unsigned long Num) = 0;
     virtual bool SendEndSignal(arnSerialInterface *HPt) = 0;
     virtual unsigned long GetpageNumber(void) = 0;
     virtual unsigned long Getpagentwrite(unsigned long Num) = 0;
     virtual unsigned long Getpagebaseaddr(unsigned long Num) = 0;
	 virtual unsigned char* Getpagedata(unsigned long Num) = 0;
     bool SendByteFormBlock8bit(arnSerialInterface *HPt, QStatusBar* outD = 0,QApplication* app = 0);
     unsigned long GetBlock8Bit_ptr(unsigned short i) {
                if (i >= numofquantum) return 0x0L;
                if (Block8bit && Block8bit[i]) return Block8bit[i]->ptr;
                else return 0x0L;
                }
     inline targetdatasize_t getTargetDataSize(void) {return targetdatasize;}
     inline targetpagesize_t getTargetPageSize(void) {return targetpagesize;}
};

class DataStreamPage32byte : public DataStream{
   private:
      #define PRGOKPAGE	((unsigned char)0xF0)
      #define PRGNOTPAGE	((unsigned char)0xF1)
      #define ADDROUTOFRANGE	((unsigned char)0xF2)

      page32bytes* pages;
      unsigned long page32bytesNumber;
   protected:

   public:
     DataStreamPage32byte(targetdatasize_t datasize = _8bit);
      ~DataStreamPage32byte(void);
      virtual bool ConvFromRecordQuantum8bit(Record* RecArr,int RecArrSize,
                unsigned short numofquan,
                unsigned long* startaddr_arr,
                unsigned long* size_arr);
      virtual bool IsDummyPage(unsigned long Num);
      virtual bool SendPage(arnSerialInterface *HPt,unsigned long Num);
      virtual bool SendEndSignal(arnSerialInterface *HPt);
      virtual unsigned long GetpageNumber(void) {return page32bytesNumber;}
      virtual unsigned long Getpagentwrite(unsigned long Num) {return pages[Num].ntwrite;}
      virtual unsigned long Getpagebaseaddr(unsigned long Num) {return pages[Num].Addr;}
      virtual unsigned char* Getpagedata(unsigned long Num) {return pages[Num].Data;}
   };

class DataStreamPage128byte : public DataStream{
   private:
      #define PRGOKPAGE	((unsigned char)0xF0)
      #define PRGNOTPAGE	((unsigned char)0xF1)
      #define ADDROUTOFRANGE	((unsigned char)0xF2)

      page128bytes* pages;
      unsigned long page128bytesNumber;
   protected:

   public:
     DataStreamPage128byte(targetdatasize_t datasize = _8bit);
      ~DataStreamPage128byte(void);
      virtual bool ConvFromRecordQuantum8bit(Record* RecArr,int RecArrSize,
                unsigned short numofquan,
                unsigned long* startaddr_arr,
                unsigned long* size_arr);
      virtual bool IsDummyPage(unsigned long Num);
      virtual bool SendPage(arnSerialInterface *HPt,unsigned long Num);
      virtual bool SendEndSignal(arnSerialInterface *HPt);
      virtual unsigned long GetpageNumber(void) {return page128bytesNumber;}
      virtual unsigned long Getpagentwrite(unsigned long Num) {return pages[Num].ntwrite;}
      virtual unsigned long Getpagebaseaddr(unsigned long Num) {return pages[Num].Addr;}
      virtual unsigned char* Getpagedata(unsigned long Num) {return pages[Num].Data;}
   };

class DataStreamPage256byte : public DataStream{
   private:
	  #define PRGOKPAGE	((unsigned char)0xF0)
	  #define PRGNOTPAGE	((unsigned char)0xF1)
	  #define ADDROUTOFRANGE	((unsigned char)0xF2)

	  page256bytes* pages;
	  unsigned long page256bytesNumber;
   protected:

   public:
	 DataStreamPage256byte(targetdatasize_t datasize = _8bit);
	  ~DataStreamPage256byte(void);
	  virtual bool IsDummyPage(unsigned long Num);
	  virtual bool ConvFromRecordQuantum8bit(Record* RecArr,int RecArrSize,
				unsigned short numofquan,
				unsigned long* startaddr_arr,
				unsigned long* size_arr);
	  virtual bool SendPage(arnSerialInterface *HPt,unsigned long Num);
	  virtual bool SendEndSignal(arnSerialInterface *HPt);
	  virtual unsigned long GetpageNumber(void) {return page256bytesNumber;}
	  virtual unsigned long Getpagentwrite(unsigned long Num) {return pages[Num].ntwrite;}
	  virtual unsigned long Getpagebaseaddr(unsigned long Num) {return pages[Num].Addr;}
	  virtual unsigned char* Getpagedata(unsigned long Num) {return pages[Num].Data;}
   };


// parte relativa ai micro con flash con tecnologia 0.18u della Renesas
// per ora supportato solo h8s2378
typedef enum {
	c018_1_BYTE,
	c018_N_BYTE,
	c018_PAGEPROG,
	c018_NONE
	} c018_t;

typedef enum {
	r018_1_BYTE,
	r018_N_BYTE,
	r018_ERROR,
	r018_MEMREAD,
	r018_NONE
	} r018_t;

#define DATA_LEN		256
typedef union _cbody {
		struct {
			unsigned char Size;
			unsigned char Data[DATA_LEN];
			unsigned char chks;
			} N_BytesC;
		struct {
			unsigned long Address;
			unsigned char Data[DATA_LEN];
			unsigned char chks;
			} PageProg;
		} cbody_t;

typedef union _rbody {
		struct {
			unsigned char Size;
			unsigned char Data[DATA_LEN];
			unsigned char chks;
			} N_BytesR;
		struct {
			unsigned char Err;
			unsigned char Code;
			} ErrorR;
		struct {
			unsigned long Size;
			unsigned char Data[DATA_LEN];
			unsigned char chks;
			} MemReadR;
		} rbody_t;

typedef struct {
	c018_t type;
	unsigned char Command;
	cbody_t body;
	} Com_t;

typedef struct {
	r018_t type;
	unsigned char Response;
	rbody_t body;
	} Res_t;

#define INQ_SEL_CMD__SUPPORTED_DEVICE_INQUIRY		0x20
#define INQ_SEL_CMD__DEVICE_SELECTION				0x10
#define INQ_SEL_CMD__CLOCK_MODE_INQUIRY				0x21
#define INQ_SEL_CMD__CLOCK_MODE_SELECTION			0x11
#define INQ_SEL_CMD__MULTIPLICATION_RATIO_INQUIRY	0x22
#define INQ_SEL_CMD__OP_CLOCK_FREQ_INQUIRY			0x23
#define INQ_SEL_CMD__USER_BOOTMAT_INFO_INQUIRY		0x24
#define INQ_SEL_CMD__USERMAT_INFO_INQUIRY			0x25
#define INQ_SEL_CMD__BLOCK_FOR_ERASING_INFO_INQUIRY	0x26
#define INQ_SEL_CMD__PROGRAMMING_UNIT_INQUIRY		0x27
#define INQ_SEL_CMD__NEW_BITRATE_SELECTION			0x3F
#define INQ_SEL_CMD__TRANS_TO_PROG_ERASE_STATE		0x40
#define INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY		0x4F

#define PRG_ERS_CMD__USER_BOOTMAT_PRG_SELECTION		0x42
#define PRG_ERS_CMD__USER_MAT_PRG_SELECTION			0x43
#define PRG_ERS_CMD__128_BYTE_PROGRAMMING			0x50
#define PRG_ERS_CMD__ERASING_SELECTION				0x48
#define PRG_ERS_CMD__BLOCK_ERASING					0x58
#define PRG_ERS_CMD__MEMORY_READ					0x52
#define PRG_ERS_CMD__USER_BOOTMAT_SUM_CHECK			0x4A
#define PRG_ERS_CMD__USER_MAT_SUM_CHECK				0x4B
#define PRG_ERS_CMD__USER_BOOTMAT_BLK_CHECK			0x4C
#define PRG_ERS_CMD__USER_MAT_BLK_CHECK				0x4D


class Command018Handler {
	private:
	protected:
		arnSerialInterface* aport;
		Com_t Command;
		Res_t Response;
		virtual c018_t cmd_to_type(unsigned char cmd);
		virtual r018_t cmd_to_res(unsigned char cmd);
		virtual bool prepareCmd(unsigned char cmd,void* hpar, void* lpar);
		virtual bool sendCmd(void);
		virtual bool receiveRes(void);
	public:
		Command018Handler (arnSerialInterface* aprt);
		virtual ~Command018Handler (void);
		Res_t* ManageCommand(unsigned char cmd,void* hpar = 0, void* lpar = 0);
		Res_t* WritePage(unsigned long address, unsigned char* bff, unsigned short len);
	};


Command018Handler::Command018Handler (arnSerialInterface* aprt)
{
	aport = aprt;
	aport->PurgeRx();
}

Command018Handler::~Command018Handler (void)
{
}

Res_t* Command018Handler::ManageCommand(unsigned char cmd,void* hpar, void* lpar)
{
	Command.type = cmd_to_type(cmd);
	if (Command.type == c018_NONE) return 0;
	if (!prepareCmd(cmd,hpar,lpar)) return 0;
	if (!sendCmd()) return 0;
	if (!receiveRes()) return 0;
	return &Response;
}

c018_t Command018Handler::cmd_to_type(unsigned char cmd)
{
	c018_t res;
	switch (cmd) {
		case INQ_SEL_CMD__SUPPORTED_DEVICE_INQUIRY: res = c018_1_BYTE; break;
		case INQ_SEL_CMD__DEVICE_SELECTION: res = c018_N_BYTE;  break;
		case INQ_SEL_CMD__CLOCK_MODE_INQUIRY: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__CLOCK_MODE_SELECTION: res = c018_N_BYTE;  break;
		case INQ_SEL_CMD__MULTIPLICATION_RATIO_INQUIRY: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__OP_CLOCK_FREQ_INQUIRY: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__USER_BOOTMAT_INFO_INQUIRY: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__USERMAT_INFO_INQUIRY: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__BLOCK_FOR_ERASING_INFO_INQUIRY: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__PROGRAMMING_UNIT_INQUIRY: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__NEW_BITRATE_SELECTION: res = c018_N_BYTE;  break;
		case INQ_SEL_CMD__TRANS_TO_PROG_ERASE_STATE: res = c018_1_BYTE;  break;
		case INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY: res = c018_1_BYTE;  break;

		case PRG_ERS_CMD__USER_BOOTMAT_PRG_SELECTION: res = c018_1_BYTE;  break;
		case PRG_ERS_CMD__USER_MAT_PRG_SELECTION: res = c018_1_BYTE;  break;
		case PRG_ERS_CMD__128_BYTE_PROGRAMMING: res = c018_N_BYTE;  break;
		case PRG_ERS_CMD__ERASING_SELECTION: res = c018_1_BYTE;  break;
		case PRG_ERS_CMD__BLOCK_ERASING: res = c018_N_BYTE;  break;
		case PRG_ERS_CMD__MEMORY_READ: res = c018_N_BYTE;  break;
		case PRG_ERS_CMD__USER_BOOTMAT_SUM_CHECK: res = c018_1_BYTE;  break;
		case PRG_ERS_CMD__USER_MAT_SUM_CHECK: res = c018_1_BYTE;  break;
		case PRG_ERS_CMD__USER_BOOTMAT_BLK_CHECK: res = c018_1_BYTE;  break;
		case PRG_ERS_CMD__USER_MAT_BLK_CHECK: res = c018_1_BYTE;  break;
		default : res = c018_NONE; break;
		}
	return res;
}

r018_t Command018Handler::cmd_to_res(unsigned char cmd)
{
	r018_t res;
	switch (cmd) {
		case INQ_SEL_CMD__SUPPORTED_DEVICE_INQUIRY: res = r018_N_BYTE; break;
		case INQ_SEL_CMD__DEVICE_SELECTION: res = r018_1_BYTE;  break;
		case INQ_SEL_CMD__CLOCK_MODE_INQUIRY: res = r018_N_BYTE;  break;
		case INQ_SEL_CMD__CLOCK_MODE_SELECTION: res = r018_1_BYTE;  break;
		case INQ_SEL_CMD__MULTIPLICATION_RATIO_INQUIRY: res = r018_N_BYTE;  break;
		case INQ_SEL_CMD__OP_CLOCK_FREQ_INQUIRY: res = r018_N_BYTE;  break;
		case INQ_SEL_CMD__USER_BOOTMAT_INFO_INQUIRY: res = r018_N_BYTE;  break;
		case INQ_SEL_CMD__USERMAT_INFO_INQUIRY: res = r018_N_BYTE;  break;
		case INQ_SEL_CMD__BLOCK_FOR_ERASING_INFO_INQUIRY: res = r018_N_BYTE;  break;
		case INQ_SEL_CMD__PROGRAMMING_UNIT_INQUIRY: res = r018_N_BYTE;  break;
		case INQ_SEL_CMD__NEW_BITRATE_SELECTION: res = r018_1_BYTE;  break;
		case INQ_SEL_CMD__TRANS_TO_PROG_ERASE_STATE: res = r018_1_BYTE;  break;
		case INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY: res = r018_N_BYTE;  break;

		case PRG_ERS_CMD__USER_BOOTMAT_PRG_SELECTION: res = r018_1_BYTE;  break;
		case PRG_ERS_CMD__USER_MAT_PRG_SELECTION: res = r018_1_BYTE;  break;
		case PRG_ERS_CMD__128_BYTE_PROGRAMMING: res = r018_1_BYTE;  break;
		case PRG_ERS_CMD__ERASING_SELECTION: res = r018_1_BYTE;  break;
		case PRG_ERS_CMD__BLOCK_ERASING: res = r018_1_BYTE;  break;
		case PRG_ERS_CMD__MEMORY_READ: res = r018_N_BYTE;  break;
		case PRG_ERS_CMD__USER_BOOTMAT_SUM_CHECK: res = r018_N_BYTE;  break;
		case PRG_ERS_CMD__USER_MAT_SUM_CHECK: res = r018_N_BYTE;  break;
		case PRG_ERS_CMD__USER_BOOTMAT_BLK_CHECK: res = r018_1_BYTE;  break;
		case PRG_ERS_CMD__USER_MAT_BLK_CHECK: res = r018_1_BYTE;  break;
		default : res = r018_NONE; break;
		}
	return res;
}

bool Command018Handler::prepareCmd(unsigned char cmd,void* hpar, void* lpar)
{
	bool res = false;
	unsigned char chks;
	switch (cmd) {
		case INQ_SEL_CMD__SUPPORTED_DEVICE_INQUIRY:
			Command.Command = INQ_SEL_CMD__SUPPORTED_DEVICE_INQUIRY;
			Response.type = r018_N_BYTE;
			Response.Response = 0x30;
			res = true;
			break;
		case INQ_SEL_CMD__DEVICE_SELECTION:
			Command.Command = INQ_SEL_CMD__DEVICE_SELECTION;
			Command.body.N_BytesC.Size = *((unsigned char*)lpar); // 4
			memcpy(Command.body.N_BytesC.Data,(char*)hpar,Command.body.N_BytesC.Size); //"0a01"
			chks = 0;
			chks += INQ_SEL_CMD__DEVICE_SELECTION;
			chks += Command.body.N_BytesC.Size;
			for (unsigned int i = 0; i < Command.body.N_BytesC.Size; i++) chks += Command.body.N_BytesC.Data[i];
			Command.body.N_BytesC.chks = ((unsigned short)0x0100) - chks;
			//
			Response.type = r018_1_BYTE;
			Response.Response = 0x06;
			res = true;
			break;
		case INQ_SEL_CMD__CLOCK_MODE_INQUIRY:
			Command.Command = INQ_SEL_CMD__CLOCK_MODE_INQUIRY;
			Response.type = r018_N_BYTE;
			Response.Response = 0x31;
			res = true;
			break;
		case INQ_SEL_CMD__CLOCK_MODE_SELECTION: {
			unsigned char clockmode = (*((unsigned char*)lpar));
			Command.Command = INQ_SEL_CMD__CLOCK_MODE_SELECTION;
			Command.body.N_BytesC.Size = 1;
			Command.body.N_BytesC.Data[0] = clockmode;
			chks = 0;
			chks += INQ_SEL_CMD__CLOCK_MODE_SELECTION;
			chks += Command.body.N_BytesC.Size;
			for (unsigned int i = 0; i < Command.body.N_BytesC.Size; i++) chks += Command.body.N_BytesC.Data[i];
			Command.body.N_BytesC.chks = ((unsigned short)0x0100) - chks;
			//
			Response.type = r018_1_BYTE;
			Response.Response = 0x06;
			res = true;
			}
			break;
		case INQ_SEL_CMD__MULTIPLICATION_RATIO_INQUIRY:
			Command.Command = INQ_SEL_CMD__MULTIPLICATION_RATIO_INQUIRY;
			Response.type = r018_N_BYTE;
			Response.Response = 0x32;
			res = true;
			break;
		case INQ_SEL_CMD__OP_CLOCK_FREQ_INQUIRY:
			Command.Command = INQ_SEL_CMD__OP_CLOCK_FREQ_INQUIRY;
			Response.type = r018_N_BYTE;
			Response.Response = 0x33;
			res = true;
			break;
		case INQ_SEL_CMD__NEW_BITRATE_SELECTION:
			Command.Command = INQ_SEL_CMD__NEW_BITRATE_SELECTION;
			Command.body.N_BytesC.Size = 7;
			Command.body.N_BytesC.Data[0] = *((unsigned char*)hpar); // Bit Rate 19200 / 100 = 192 (0x00c0); 38400 / 100 = 384 (0x0180)
			Command.body.N_BytesC.Data[1] = *((unsigned char*)(hpar) + 1);
			Command.body.N_BytesC.Data[2] = *((unsigned char*)(hpar) + 2);//0x06; // Input Frequency 16 Mhz (1600 decine di KHz (0x0640))
			Command.body.N_BytesC.Data[3] = *((unsigned char*)(hpar) + 3);//0x40;
			Command.body.N_BytesC.Data[4] = *((unsigned char*)(hpar) + 4);//0x01; // Number of Multiplication Ratios
			Command.body.N_BytesC.Data[5] = *((unsigned char*)(hpar) + 5);//0x01; // Operating
			Command.body.N_BytesC.Data[6] = *((unsigned char*)(hpar) + 6);//0x01; // Peripheral
			chks = 0;
			chks += INQ_SEL_CMD__NEW_BITRATE_SELECTION;
			chks += Command.body.N_BytesC.Size;
			for (unsigned int i = 0; i < Command.body.N_BytesC.Size; i++) chks += Command.body.N_BytesC.Data[i];
			Command.body.N_BytesC.chks = ((unsigned short)0x0100) - chks;
			//
			Response.type = r018_1_BYTE;
			Response.Response = 0x06;
			res = true;
			break;
		case INQ_SEL_CMD__TRANS_TO_PROG_ERASE_STATE:
			Command.Command = INQ_SEL_CMD__TRANS_TO_PROG_ERASE_STATE;
			Response.type = r018_1_BYTE;
			Response.Response = 0x06;
			res = true;
			break;
		case PRG_ERS_CMD__USER_BOOTMAT_PRG_SELECTION:
			Command.Command = PRG_ERS_CMD__USER_BOOTMAT_PRG_SELECTION;
			Response.type = r018_1_BYTE;
			Response.Response = 0x06;
			res = true;
			break;
		case PRG_ERS_CMD__USER_MAT_PRG_SELECTION:
			Command.Command = PRG_ERS_CMD__USER_MAT_PRG_SELECTION;
			Response.type = r018_1_BYTE;
			Response.Response = 0x06;
			res = true;
			break;
		case INQ_SEL_CMD__USERMAT_INFO_INQUIRY:
			Command.Command = INQ_SEL_CMD__USERMAT_INFO_INQUIRY;
			Response.type = r018_N_BYTE;
			Response.Response = 0x35;
			res = true;
			break;
		case INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY:
			Command.Command = INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY;
			Response.type = r018_N_BYTE;
			Response.Response = 0x5F;
			res = true;
			break;
		default : break;
		}
	return res;
}

bool Command018Handler::sendCmd(void)
{
	bool res = false;
	unsigned char Tx_Buffer;
	switch (Command.type) {
		case c018_1_BYTE:
			Tx_Buffer = Command.Command;
			aport->PurgeRx();
			if (!aport->SendData((char*)&Tx_Buffer,1)) {
				fprintf(stderr,"Errore trasmissione comando:0x%x2\r\n",Command.Command);
				return false;
				}
			res = true;
			break;
		case c018_N_BYTE:
			Tx_Buffer = Command.Command;
			aport->PurgeRx();
			if (!aport->SendData((char*)&Tx_Buffer,1)) {
				fprintf(stderr,"Errore trasmissione comando:0x%x2\r\n",Command.Command);
				return false;
				}
			Tx_Buffer = Command.body.N_BytesC.Size;
			aport->PurgeRx();
			if (!aport->SendData((char*)&Tx_Buffer,1)) {
				fprintf(stderr,"Errore trasmissione size:0x%x2\r\n",Command.Command);
				return false;
				}
			for (unsigned int i = 0; i < Command.body.N_BytesC.Size; i++) {
				Tx_Buffer = Command.body.N_BytesC.Data[i];
				aport->PurgeRx();
				if (!aport->SendData((char*)&Tx_Buffer,1)) {
					fprintf(stderr,"Errore trasmissione data:0x%x2\r\n",Command.Command);
					return false;
					}
				}
			Tx_Buffer = Command.body.N_BytesC.chks;
			aport->PurgeRx();
			if (!aport->SendData((char*)&Tx_Buffer,1)) {
				fprintf(stderr,"Errore trasmissione chks:0x%x2\r\n",Command.Command);
				return false;
				}
			res = true;
			break;
		default : break;
		}
	return res;
}

bool Command018Handler::receiveRes(void)
{
	bool res = false;
	unsigned char Rx_Buffer;
	unsigned char chks;
	switch (Response.type) {
		case r018_N_BYTE: {
			chks = 0;
			unsigned char i;
			if (Command.Command == INQ_SEL_CMD__SUPPORTED_DEVICE_INQUIRY) {
				Rx_Buffer = 0xFF;
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x\r\n",Command.Command);
					return false;
					}
				if (Rx_Buffer != Response.Response) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. Codice risposta errato.\r\n",Command.Command);
					return false;
					}
				chks += Rx_Buffer;
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. size non pervenuta.\r\n",Command.Command);
					return false;
					}
				Response.body.N_BytesR.Size = Rx_Buffer;
				chks += Rx_Buffer;
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. size non pervenuta.\r\n",Command.Command);
					return false;
					}
				chks += Rx_Buffer;
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. size non pervenuta.\r\n",Command.Command);
					return false;
					}
				chks += Rx_Buffer;
				for (i = 0; i < (Response.body.N_BytesR.Size - 2); i++) {
					if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
						fprintf(stderr,"Errore ricezione risposta comando:0x%02x. errore sui data.\r\n",Command.Command);
						return false;
						}
					Response.body.N_BytesR.Data[i] = Rx_Buffer;
					chks += Rx_Buffer;
					}
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. size non pervenuta.\r\n",Command.Command);
					return false;
					}
				chks += Rx_Buffer;
				if (chks != 0) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x.Chks errata.\r\n",Command.Command);
					return false;
					}
				}
			else if ((Command.Command == INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY) ||
				(Command.Command == INQ_SEL_CMD__CLOCK_MODE_INQUIRY) ||
				(Command.Command == INQ_SEL_CMD__USERMAT_INFO_INQUIRY) ||
				(Command.Command == INQ_SEL_CMD__MULTIPLICATION_RATIO_INQUIRY) ||
				(Command.Command == INQ_SEL_CMD__OP_CLOCK_FREQ_INQUIRY)
				) {
				Rx_Buffer = 0xFF;
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x\r\n",Command.Command);
					return false;
					}
				if (Rx_Buffer != Response.Response) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. Codice risposta errato.\r\n",Command.Command);
					return false;
					}
				chks += Rx_Buffer;
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. size non pervenuta.\r\n",Command.Command);
					return false;
					}
				Response.body.N_BytesR.Size = Rx_Buffer;
				chks += Rx_Buffer;
				for (i = 0; i < Response.body.N_BytesR.Size; i++) {
					if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
						fprintf(stderr,"Errore ricezione risposta comando:0x%02x. errore sui data.\r\n",Command.Command);
						return false;
						}
//fprintf(stderr,"\tData[%d]:0x%02x\r\n",i,Rx_Buffer);
					Response.body.N_BytesR.Data[i] = Rx_Buffer;
					chks += Rx_Buffer;
					}
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. size non pervenuta.\r\n",Command.Command);
					return false;
					}
				chks += Rx_Buffer;
				if (chks != 0) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x.Chks errata.\r\n",Command.Command);
					return false;
					}
				}
			}
			res = true;
			break;
		case r018_1_BYTE:
			if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
				fprintf(stderr,"Errore ricezione risposta comando:0x%02x. ack non pervenuta.\r\n",Command.Command);
				return false;
				}
			if (Response.Response != Rx_Buffer) {
				Response.type = r018_ERROR;
				Response.body.ErrorR.Err = Rx_Buffer;
				if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
					fprintf(stderr,"Errore ricezione risposta comando:0x%02x. err code non pervenuto.\r\n",Command.Command);
					return false;
					}
				Response.body.ErrorR.Code = Rx_Buffer;
				}
			res = true;
			break;
		default : break;
		}
	return res;
}

Res_t* Command018Handler::WritePage(unsigned long address, unsigned char* bff, unsigned short len)
{
	unsigned char Tx_Buffer,Rx_Buffer;
	// prepare
	Command.type = cmd_to_type(PRG_ERS_CMD__128_BYTE_PROGRAMMING);
	if (Command.type == c018_NONE) return 0;
	Command.Command = PRG_ERS_CMD__128_BYTE_PROGRAMMING;
	Command.body.PageProg.chks = Command.Command;
	Command.body.PageProg.Address = address;
	unsigned char* ptmp = ((unsigned char*)(&(Command.body.PageProg.Address)));
	for (unsigned int i = 0; i < 4; i++) {
		Command.body.PageProg.chks += ptmp[i];
		}
	memset(Command.body.PageProg.Data,0xff,DATA_LEN);
	for (unsigned int i = 0; i < len; i++) {
		if (i < len) Command.body.PageProg.Data[i] = bff[i];
		Command.body.PageProg.chks += Command.body.PageProg.Data[i];
		}
	Command.body.PageProg.chks = ((unsigned short)0x0100) - Command.body.PageProg.chks;
	//
	Response.type = r018_1_BYTE;
	Response.Response = 0x06;
	// FINE --- prepare

	// send
	Tx_Buffer = Command.Command;
	aport->PurgeRx();
	if (!aport->SendData((char*)&Tx_Buffer,1)) {
		fprintf(stderr,"Errore trasmissione comando:0x%2x\r\n",Command.Command);
		return 0;
		}
	//fprintf(stdout,"0x%2x..\r\n",Tx_Buffer);
//fprintf(stdout,"\r\n");
	unsigned long ltp = lmirror(Command.body.PageProg.Address);
	ptmp = ((unsigned char*)(&ltp));
	for (unsigned int i = 0; i < 4; i++) {
		Tx_Buffer = ptmp[i];
		aport->PurgeRx();
		if (!aport->SendData((char*)&Tx_Buffer,1)) {
			fprintf(stderr,"Errore trasmissione address:0x%2x\r\n",Command.Command);
			return 0;
			}
		//fprintf(stdout,"0x%2x..\r\n",Tx_Buffer);
		}
//fprintf(stdout,"\r\n");
	for (unsigned int i = 0; i < len; i++) {
		Tx_Buffer = Command.body.PageProg.Data[i];
		aport->PurgeRx();
		if (!aport->SendData((char*)&Tx_Buffer,1)) {
			fprintf(stderr,"Errore trasmissione data:0x%2x\r\n",Command.Command);
			return 0;
			}
	//fprintf(stdout,"0x%2x..\r\n",Tx_Buffer);
		}
//fprintf(stdout,"\r\n");
	Tx_Buffer = Command.body.PageProg.chks;
	aport->PurgeRx();
	if (!aport->SendData((char*)&Tx_Buffer,1)) {
		fprintf(stderr,"Errore trasmissione chks:0x%2x\r\n",Command.Command);
		return 0;
		}
	//fprintf(stdout,"0x%2x..\r\n",Tx_Buffer);
	// FINE --- send
//fprintf(stdout,"\r\n\r\n\r\n");

	// receice RES
	Rx_Buffer = 0xff;
	if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
		fprintf(stderr,"Errore ricezione risposta comando:0x%2x. ack non pervenuta.\r\n",Command.Command);
		return 0;
		}
	//fprintf(stderr,"0x%2x..\r\n",Rx_Buffer);
	//fprintf(stderr,"0x%2x..\r\n",Response.Response);
	if (Response.Response != Rx_Buffer) {
		Response.type = r018_ERROR;
		Response.body.ErrorR.Err = Rx_Buffer;
		Rx_Buffer = 0xff;
		if ((!aport->ReceiveData((char*)&Rx_Buffer,1))) {
			fprintf(stderr,"Errore ricezione risposta comando:0x%2x. err code non pervenuto.\r\n",Command.Command);
			return 0;
			}
		//fprintf(stderr,"0x%2x..\r\n",Rx_Buffer);
		Response.body.ErrorR.Code = Rx_Buffer;
		return 0;
		}
	// FINE --- receice RES
	
	return &Response;
}

// FINE --- parte relativa ai micro con flash con tecnologia 0.18u della Renesas
















//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------
//---
//---  arnSAParametric
//---
//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------



arnSAParametric::arnSAParametric(unsigned int dim)
    : arnParametric(dim)
{
    serInterfType = ci_None;
    strcpy(serInterfName,"");
    pDev = 0;
    firmware = new FirmwareDescr_t;
    if (!firmware) exit(EXIT_FAILURE);
}

arnSAParametric::arnSAParametric(unsigned int dim,unsigned int nSegs)
    : arnParametric(dim,nSegs)
{
    serInterfType = ci_None;
    strcpy(serInterfName,"");
    pDev = 0;
    firmware = new FirmwareDescr_t;
    if (!firmware) exit(EXIT_FAILURE);
}

arnSAParametric::arnSAParametric(const arnSAParametric& aPar)
    : arnParametric(aPar)
{
    serInterfType = aPar.serInterfType;
    strcpy(serInterfName,aPar.serInterfName);
    pDev = 0;
    firmware = new FirmwareDescr_t;
    if (!firmware) exit(EXIT_FAILURE);
}

arnSAParametric::~arnSAParametric(void)
{
    if (firmware) {delete firmware; firmware = 0;}
}

arnSAParametric& arnSAParametric::operator = (const arnSAParametric& aPar)
{
    serInterfType = aPar.serInterfType;
    strcpy(serInterfName,aPar.serInterfName);
    pDev = 0;
    (*pMappa) = (*(aPar.pMappa));
    (*firmware) = (*(aPar.firmware));
    return (*this);
}

bool arnSAParametric::send(void)
{
    unsigned char maxautobaudrateTemp = 3;
    if (!isAValidMappa) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}

    if (firmware->TargetCpu == Ctt_None) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}
    if (serInterfType == ci_None) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}
    if (!strcmp(serInterfName,"")) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}
    
    if (!loadBootProgram()) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}
    if (!loadDataStream()) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}

    // test test test
    //{
    //FILE *pF = fopen("./pptt.srec","wt");
    //if (!pF) return false;
    //for (int i = 0; i < firmware->file.count(); i++)
    //            fprintf(pF,"%s",firmware->file.at(i).latin1());
    //fclose(pF);
    //}
    //FINE - test test test

    do {
        if (!AutoBaudRate()) {
                maxautobaudrateTemp--;
                arnSleep(500);
                }
        else break;
    } while (maxautobaudrateTemp);
    if (!maxautobaudrateTemp) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}
    if (!DownloadBootProgram()) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}
    if (!DownloadTargetProgram(firmware)) {arnDebug("%s,%s,%d\n",__FILE__,__FUNCTION__,__LINE__); return false;}

    return true;
}

bool arnSAParametric::receive(void)
{
    if (!pMon) return false;
    unsigned int PackSize = pMon->MaxMessLen() / 2;
    unsigned int numOfPacks = pMappa->getmemWrapper()->memImageDim / PackSize;
    unsigned int TotNumBytesToSend = pMappa->count() * pMappa->getmemWrapper()->memImageDim;
    unsigned int CurNumBytesSent = 0;
    double Perc = 0;
    for (unsigned int indx = 0; indx < pMappa->count(); indx++) {
        unsigned int addr =  pMappa->getmemWrapper(indx)->memImageDisp;
        unsigned int ptr = 0;
        char bff[512];
        unsigned int lbff;
        int ltbff;

        memset(bff,0,sizeof(bff));
        for (unsigned int j = 0; j < numOfPacks; j++) {
            if (!pMon->GetMemorySeg((unsigned char*)bff, &lbff, (unsigned char*)(addr + ptr), PackSize)) {
                return false;
                }
            if (lbff != (2 * PackSize)) return false;
            arnHexDigitToBin((unsigned char*)(pMappa->getmemWrapper(indx)->memoryImg.arr + ptr),&ltbff,(char*) bff,lbff);
            if ((2 * ((unsigned int)ltbff)) != lbff) return false;
            ptr += PackSize;
            CurNumBytesSent += PackSize;
            Perc = 100.00 * (((double)CurNumBytesSent) / TotNumBytesToSend);
            __UI_OUTPUT("Trasferimento in corso... %d %s ricevuto.\n",int(Perc),"%");
            __PROCESS();
            }
        if (!pMon->GetMemorySeg((unsigned char*)bff, &lbff, (unsigned char*)(addr + ptr),pMappa->getmemWrapper(indx)->memImageDim - ptr)) {
            return false;
            }
        if (lbff != (2 * (pMappa->getmemWrapper(indx)->memImageDim - ptr))) return false;
        arnHexDigitToBin((unsigned char*)(pMappa->getmemWrapper(indx)->memoryImg.arr + ptr),&ltbff,(char*) bff,lbff);
        if ((2 * ((unsigned int)ltbff)) != lbff) return false;
        CurNumBytesSent += (pMappa->getmemWrapper(indx)->memImageDim - ptr);
        Perc = 100.00 * (((double)CurNumBytesSent) / TotNumBytesToSend);
        __UI_OUTPUT("Trasferimento in corso... %d %s ricevuto.\n",int(Perc),"%");
        __PROCESS();
        }
    __UI_OUTPUT("Trasferimento terminato con successo.\n");
    __PROCESS();
     isAValidMappa = true;
   return true;
}

bool arnSAParametric::setFirmwareFileName(const char* absdir, const char* filename)
{
    char *t;
    int l;

    if (!arnFindFile(absdir,filename)) return false;
    l = strlen(absdir) + strlen(filename) + 2;
    t = (char*)malloc(l * sizeof(char));
    if (!t) return false;

    memset(t, 0, l * sizeof(char));
    strcpy(t,absdir);
    strcat(t,"/");
    strcat(t,filename);

    firmware->filename = t;
    free(t); t = 0;
    return true;
}

bool arnSAParametric::setFirmwareSRECFormat(QStringList *pfilelist)
{
	QString arr;
	if (!pfilelist) return false;
	firmware->file.clear();
	for (int indx = 0; indx < pfilelist->count(); indx++) {
		arr = (*pfilelist)[indx].toLatin1();
		firmware->file.append(arr);
		//BEGIN debug
		//printf("%s\n",firmware->file.at(firmware->file.count() - 1).latin1());
		//END debug
		}
    return true;
}


bool arnSAParametric::loadDataStream(void)
{
    FILE* hf;
    char* pBuff;
    //QStrList res;
    int c;
    QString arr;
    QString S8record;

    enum _lineprogramparsState {lps_start_pars,lps_start_line,lps_foundlinefeed,
        lps_foundcarriagereturn,lps_none,lps_err} lineprogramparsState = lps_start_pars;

    if (firmware->file.isEmpty() && firmware->filename == "") return false;
    if (firmware->filename != "") {
        firmware->file.clear();
        hf = fopen(firmware->filename.toLatin1().constData(),"rb");
        if (!hf) return false;
        arr = "";
        while ((c = fgetc(hf)) != EOF) {
            arr += ((char) c);
            switch (lineprogramparsState) {
                case lps_start_pars:
                    if (c == 'S') lineprogramparsState = lps_start_line;
                    break;
                case lps_start_line:
                    if (c == '\r') lineprogramparsState = lps_foundlinefeed;
                    else if (c == '\n') {
						lineprogramparsState = lps_start_pars;
	                    arr += ((char) '\0');
	                    firmware->file.append(arr);
	                    arr = "";
						}
                    break;
                case lps_foundlinefeed:
                    if (c == '\n') lineprogramparsState = lps_start_pars;
                    arr += ((char) '\0');
                    firmware->file.append(arr);
                    arr = "";
                    break;
                default:
                    break;
                }
            }
        fclose(hf);
        }
    else { // file is a not empty list
            // check su tutti i caratteri usando count, current e next
        }


    //  parte che carica i parametri se ci sono
    pBuff = new char[PBUFF_SIZE];
    if (!pBuff) return false;

	if (ConvertTabToA20((unsigned char*)pBuff,PBUFF_SIZE)) {
		//Aggiunta a res di questo nuovo a20 prodotto
		arr = "";
		lineprogramparsState = lps_start_pars;
		S8record = firmware->file.last();
		
		if (firmware->file.isEmpty()) exit (EXIT_FAILURE); // se vuoto
		firmware->file.removeLast();
		for (unsigned int indx = 0; pBuff[indx] != '\0'; indx++) {
			c = pBuff[indx];
			arr += ((char) c);
			switch (lineprogramparsState) {
				case lps_start_pars:
					if (c == 'S') lineprogramparsState = lps_start_line;
					break;
				case lps_start_line:
					if (c == '\r') lineprogramparsState = lps_foundlinefeed;
					break;
				case lps_foundlinefeed:
					if (c == '\n') lineprogramparsState = lps_start_pars;
					arr += ((char) '\0');
					firmware->file.append(arr);
					arr = "";
					break;
				default:
					break;
				}
			}
		firmware->file.append(S8record);
		}
	else {fprintf(stderr,"Errore conversione ad srec format.\n");exit(EXIT_FAILURE);}

    delete [] pBuff;
    pBuff = 0;
    return true;
}

bool arnSAParametric::exportSRECTotalFile(const char* absdir, const char* filename)
{
	bool res = false;
	char *t;
	int l;
	FILE* fd;

	l = strlen(absdir) + strlen(filename) + 2;
	t = (char*)malloc(l * sizeof(char));
	if (!t) return res;

	memset(t, 0, l * sizeof(char));
	strcpy(t,absdir);
	strcat(t,"/");
	strcat(t,filename);
//BEGIN test test test
arnDebug("step1\n");
//END test test test
	if (!loadDataStream()) {
//BEGIN test test test
arnDebug("step2\n");
//END test test test
		free(t); t = 0; 
		return res;
		}
//BEGIN test test test
arnDebug("%s\n",t);
//END test test test
	fd = fopen(t,"w");
	if (!fd) {
//BEGIN test test test
arnDebug("step3\n");
//END test test test
		free(t); t = 0; 
		return res;
		}
	QStringList::iterator i;
	for (i = firmware->file.begin(); i != firmware->file.end(); ++i) {
		int len = strlen(i->toLatin1().data());
		for (int indx = 0; indx < len; indx++) {
			fputc(i->toLatin1().data()[indx],fd);
			}
		}
	fclose(fd);
	free(t); t = 0;
	res = true;
	return res;
}

bool arnSAParametric::KLoaderEmu(const char* fname)
{
	FILE* hf;
	//QStrList res;
	int c;
	QString arr;
	FirmwareDescr_t lFirmD;
	enum _lineprogramparsState {
		lps_start_pars,
		lps_start_line,
		lps_foundlinefeed,
		lps_foundcarriagereturn,
		lps_none,lps_err
	} lineprogramparsState = lps_start_pars;

	if (!fname) {arnDebug("1"); return false;}
	lFirmD.BootProgram = firmware->BootProgram;
	lFirmD.TargetCpu = firmware->TargetCpu;
	lFirmD.file.clear();
	hf = fopen(fname,"rb");
	if (!hf) {arnDebug("2"); return false;}
	arr = "";
	while ((c = fgetc(hf)) != EOF) {
		arr += ((char) c);
		switch (lineprogramparsState) {
			case lps_start_pars:
				if (c == 'S') lineprogramparsState = lps_start_line;
				break;
			case lps_start_line:
				if (c == '\r') lineprogramparsState = lps_foundlinefeed;
				else if (c == '\n') {
					lineprogramparsState = lps_start_pars;
					arr += ((char) '\0');
					lFirmD.file.append(arr);
					arr = "";
					}
				break;
			case lps_foundlinefeed:
				if (c == '\n') lineprogramparsState = lps_start_pars;
				arr += ((char) '\0');
				lFirmD.file.append(arr);
				arr = "";
				break;
			default:
				break;
			}
		}
	fclose(hf);

	unsigned char maxautobaudrateTemp = 3;


	if (lFirmD.TargetCpu == Ctt_None) {arnDebug("3"); return false;}
	if (serInterfType == ci_None) {arnDebug("4"); return false;}
	if (!strcmp(serInterfName,"")) {arnDebug("5"); return false;}

	if (!loadBootProgram()) {arnDebug("6"); return false;}
	lFirmD.BootProgram = firmware->BootProgram;

	// test test test
//    {
//    FILE *pF = fopen("./pptt.srec","wt");
//    if (!pF) return false;
//    for (int i = 0; i < firmware->file.count(); i++)
// 		fprintf(pF,"%s",firmware->file.at(i).latin1());
//    fclose(pF);
//    }

	//if (!AutoBaudRate()) return false;
	do {
		if (!AutoBaudRate()) {
			maxautobaudrateTemp--;
			arnSleep(500);
			}
		else break;
		} while (maxautobaudrateTemp);
	if (!maxautobaudrateTemp) {arnDebug("7"); return false;}
	if (!DownloadBootProgram()) {arnDebug("8"); return false;}

	if (!DownloadTargetProgram(&lFirmD)) {arnDebug("1"); return false;}

	return true;
}

//---------------------------------------------------------------------------
unsigned char* arnSAParametric::ConvertTabToA20(unsigned char* destBuff,unsigned long Size)
{
if (!destBuff || !Size) return false;
for (unsigned int indx = 0; indx < pMappa->count(); indx++) {
    QString Carat(""),NumBytes("");
    int RecordNumber = pMappa->getmemWrapper(indx)->memImageDim  /  16;
    bool ExistLastRecord = ((pMappa->getmemWrapper(indx)->memImageDim % 16) != 0);
    unsigned int LocStart = 0;
    for (int i = 0; i < RecordNumber; i++) {
        unsigned char Chks;
        QString Temp(""),t("");
        if ((pMappa->getmemWrapper(indx)->memImageDisp + LocStart) < 0x10000) {
            Carat = "S1";
            NumBytes = "13";
            Chks = 0x13;
            QString P;QString t;
            P.sprintf("%4.4x",(pMappa->getmemWrapper(indx)->memImageDisp + LocStart));
            Temp += Carat;
            Temp += NumBytes;
            Temp += P;
            char tc[3];
            strcpy(tc,P.mid(0,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            strcpy(tc,P.mid(2,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            }
        else {
            Carat = "S2";
            NumBytes = "14";
            Chks = 0x14;
            QString P("");
            P.sprintf("%6.6x",(pMappa->getmemWrapper(indx)->memImageDisp + LocStart));
            Temp += Carat;
            Temp += NumBytes;
            Temp += P;
            char tc[3];
            strcpy(tc,P.mid(0,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            strcpy(tc,P.mid(2,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            strcpy(tc,P.mid(4,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            }
        for (int j = 0; j < 16; j++) {
            Chks += pMappa->getmemWrapper(indx)->memoryImg.arr[LocStart + j];
            t.sprintf("%2.2x",( pMappa->getmemWrapper(indx)->memoryImg.arr[LocStart + j]));
            Temp += t;
            }
        Chks =(unsigned char) ~Chks;
        t.sprintf("%2.2x",Chks);
        Temp += t;
        Temp += "\r\n";
        if (strlen((const char*)destBuff) > Size) return NULL;
        Temp = Temp.toUpper();
        strcpy((char*)(destBuff),Temp.toLatin1().constData());
        destBuff += Temp.length();
        LocStart += 16;
        //fprintf(stderr,"%s",Temp.data());
        }
    /* ultimo record*/
    if (ExistLastRecord) {
        unsigned char Nbytes = (unsigned char) (pMappa->getmemWrapper(indx)->memImageDim - LocStart);
        unsigned char Chks;
        QString Temp(""),t("");
        if ((pMappa->getmemWrapper(indx)->memImageDisp + LocStart) < 0x10000) {
            Carat = "S1";
            t.sprintf("%2.2x",(Nbytes + 3));
            NumBytes = t;
            Chks = Nbytes;
            QString P("");
            P.sprintf("%4.4x",(pMappa->getmemWrapper(indx)->memImageDisp + LocStart));
            Temp += Carat;
            Temp += NumBytes;
            Temp += P;
            char tc[3];
            strcpy(tc,P.mid(0,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            strcpy(tc,P.mid(2,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            }
        else {
            Carat = "S2";
            t.sprintf("%2.2x",(Nbytes + 4));
            NumBytes = t;
            Chks = Nbytes;
            QString P("");
            P.sprintf("%6.6x",(pMappa->getmemWrapper(indx)->memImageDisp + LocStart));
            Temp += Carat;
            Temp += NumBytes;
            Temp += P;
            char tc[3];
            strcpy(tc,P.mid(0,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            strcpy(tc,P.mid(2,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            strcpy(tc,P.mid(4,2).toLatin1().constData()); Chks += (unsigned char) atolh((char*)tc);
            }
        for (unsigned int j = LocStart; j < pMappa->getmemWrapper(indx)->memImageDim; j++) {
            Chks +=  pMappa->getmemWrapper(indx)->memoryImg.arr[/*LocStart +*/ j];
            t.sprintf("%2.2x",( pMappa->getmemWrapper(indx)->memoryImg.arr[/*LocStart*/ + j]));
            Temp += t;
            }
        Chks =(unsigned char) ~Chks;
        t.sprintf("%2.2x",Chks);
        Temp += t;
        Temp += "\r\n";
        if (strlen((const char*)destBuff) > Size) return NULL;
        Temp = Temp.toUpper();
        strcpy((char*)(destBuff),Temp.toLatin1().constData());
        destBuff += Temp.length();
        }
    }
*destBuff = '\0';
return destBuff;
}
//---------------------------------------------------------------------------
bool arnSAParametric::loadBootProgram(void)
{
	int lIndexLine;
	CpuTarget_t cpu = firmware->TargetCpu;
	firmware->BootProgram.clear();
	if ((cpu == Ctt_H8S2378_16MHZ) ||
		(cpu == Ctt_SH27085_10MHZ) ||
		(cpu == Ctt_SH2A7286_12MHZ)) {
		// questa tecnologia ha il boot program integrato; pertanto non occorre
		}
	else {
		//if (cpu == Ctt_MNJ600RAM) cpu = Ctt_SH27044;
		lIndexLine = 0;
		while (bootprogram[cpu][lIndexLine] != NULL) {
			int lIndex_Char;
			QString arr("");
			lIndex_Char = 0;
			while (bootprogram[cpu][lIndexLine][lIndex_Char] != '\0') {
				arr += bootprogram[cpu][lIndexLine][lIndex_Char];
				lIndex_Char++;
				}
			arr += '\r';
			arr += '\n';
			arr += '\0';
			firmware->BootProgram.append(arr);
			lIndexLine++;
			}
			N_SECTORS = N_SECTS[cpu];
		}
    return true;
}

///* --------------------- FUNZIONI INIZIO COMUNICAZIONE --------------- */
bool arnSAParametric::AutoBaudRate(void)
{
    bool ReceiveOk;
    char Rx_Buffer = 0;
    char Tx_Buffer = 0;
    int cerr = 5;

    portdef PComDef;
    strcpy(PComDef.portname,serInterfName);
	if ((firmware->TargetCpu == Ctt_H8S2378_16MHZ) ||
		(firmware->TargetCpu == Ctt_H83048FONE_16MHZ) ||
		(firmware->TargetCpu == Ctt_SH27085_10MHZ) ||
		(firmware->TargetCpu == Ctt_SH2A7286_12MHZ)
		) PComDef.baudrate = 19200;
	else PComDef.baudrate = 9600;
    PComDef.databits = 8;
    PComDef.parity = 0;
    PComDef.stopbits = 1;
    PComDef.xon_xoff = false;
    PComDef.rts_cts = false;
    PComDef.timeout = 3;

    if (serInterfType == ci_COM) {
        if (!pDev) pDev = new arnComPort(PComDef);
        if (!pDev) return false;
		if (pDev->GetStatus()) {
			if (pDev->GetStatus() == 3) {
				fprintf(stderr,"Port already opened.\n");
				if (pDev) {delete pDev; pDev = 0;}
				return false;
				}
			else {
				fprintf(stderr,"Check permission on port.\n");
				if (pDev) {delete pDev; pDev = 0;}
				return false;
				}
			}
        }
    else return false;

    // -------------- autobaudrate ------------------------------------------------
	if ((firmware->TargetCpu == Ctt_H8S2378_16MHZ) ||
		(firmware->TargetCpu == Ctt_SH27085_10MHZ) ||
		(firmware->TargetCpu == Ctt_SH2A7286_12MHZ)) {
		Tx_Buffer = 0x00;
		__UI_OUTPUT("Autobaudrate in corso...");
		do {
			pDev->PurgeRx();
			if (!pDev->SendData(&Tx_Buffer,1)) {
				__UI_OUTPUT("errore trasmissione 0x00 in autobaudrate!!!");
				if (pDev) {delete pDev; pDev = 0;}
				return false;
				}
			Rx_Buffer = 0xFF;
			ReceiveOk = pDev->ReceiveData(&Rx_Buffer,1);
			if (!ReceiveOk) {
				continue;
				}
			} while ((Rx_Buffer != 0x00) && (cerr--));
		if (!cerr) {
			__UI_OUTPUT("Errore nel ricevere 0x00 per l'autobudrate: Timeout. Controllare le connessioni");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		Tx_Buffer = 0x55;
		pDev->PurgeRx();
		if (!pDev->SendData(&Tx_Buffer,1)) {
			__UI_OUTPUT("Errore nel trasmettere 0x55 per la sincronizzazione");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		Rx_Buffer = 0xFF;
		if ((!pDev->ReceiveData(&Rx_Buffer,1)) || (Rx_Buffer != ((char) 0xE6))) {
			__UI_OUTPUT("Errore nel ricevere il carattere di sincronizzazione");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		}
	else {
	    // comportamento spurio quando ci agganciamo: ci manda un zero inatteso
		if ((firmware->TargetCpu == Ctt_SH27044) || (firmware->TargetCpu == Ctt_SH27044F)) pDev->ReceiveData(&Rx_Buffer,1);
		__UI_OUTPUT("Autobaudrate in corso...");
		Tx_Buffer = 0x00;
		do {
			pDev->PurgeRx();
			if (!pDev->SendData(&Tx_Buffer,1)) {
				__UI_OUTPUT("errore trasmissione 0x00 in autobaudrate!!!");
				if (pDev) {delete pDev; pDev = 0;}
				return false;
				}
			Rx_Buffer = 0xFF;
			ReceiveOk = pDev->ReceiveData(&Rx_Buffer,1);
			if (!ReceiveOk) continue;
			__PROCESS();
			} while ((Rx_Buffer != 0x00) && (cerr--));
		if (!cerr) {
			__UI_OUTPUT("Errore nel ricevere 0x00 per l'autobudrate: Timeout. Controllare le connessioni");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		Tx_Buffer = 0x55;
		pDev->PurgeRx();
		if (!pDev->SendData(&Tx_Buffer,1)) {
			__UI_OUTPUT("Errore nel trasmettere 0x55 per la sincronizzazione");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		if ((!pDev->ReceiveData(&Rx_Buffer,1)) || (Rx_Buffer != ((char) 0xAA))) {
			__UI_OUTPUT("Errore nel ricevere 0xAA per la sincronizzazione");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		__UI_OUTPUT("Autobaudrate OK.");
		}
	return true;
}






//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------
//---
//---  DA Main
//---
//------------------------------------------------------------
//------------------------------------------------------------
//------------------------------------------------------------






//static CpuTarget_t convtocpu(char* cpu)
//{
//	if (!strcmp(cpu,"H83048") || !strcmp(cpu,"h83048")) return Ctt_H83048;
//	else if (!strcmp(cpu,"H8S2345") || !strcmp(cpu,"h8s2345")) return Ctt_H8S2345;
//	else if (!strcmp(cpu,"SH27044") || !strcmp(cpu,"sh27044")) return Ctt_SH27044;
//	else if (!strcmp(cpu,"SH27044F") || !strcmp(cpu,"sh27044f")) return Ctt_SH27044F;
//	else if (!strcmp(cpu,"SH2MNJ600") || !strcmp(cpu,"sh2mnj600")) return Ctt_SH2MNJ600;
//	else if (!strcmp(cpu,"MNJ600RAM") || !strcmp(cpu,"mnj600ram")) return Ctt_MNJ600RAM;
//	else return Ctt_None;
//
//}



///* ******************************************************************* */
//
//
///* ******************************************************************* */
bool arnSAParametric::DownloadBootProgram(void)
{
    unsigned short numofdtbootpquantum = 1;
    unsigned long StartAddressdtbootpquantum;
    unsigned long Sizedtbootpquantum;

    if (serInterfType == ci_None) return false;
    if (!strcmp(serInterfName,"")) return false;

//    if (firmware->TargetCpu == Ctt_MNJ600RAM) return true;
    
    char Rx_Buffer[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    char Tx_Buffer[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	DataStream* dtbootp = 0;
	switch (firmware->TargetCpu) {
		case Ctt_SH27044: {
			dtbootp = new DataStreamPage32byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xFFFFF000;
			Sizedtbootpquantum = 0xC00;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
		case Ctt_SH27044F: {
			dtbootp = new DataStreamPage32byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xFFFFF000;
			Sizedtbootpquantum = 0xC00;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
		case Ctt_H8S2345: {
			dtbootp = new DataStreamPage32byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0x00FFF400;
			Sizedtbootpquantum = 0xC00;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
                case Ctt_H8S2345Z24E: {
                        dtbootp = new DataStreamPage32byte(_8bit);
                        unsigned int NumOfRecord = firmware->BootProgram.count();
                        Record* Prg = new Record[NumOfRecord];
                        for (unsigned int i = 0; i < NumOfRecord; i++) {
                                Record *PrgLocal;
                                PrgLocal = new Record(firmware->BootProgram.at(i));
                                Prg[i] = (*PrgLocal);
                                delete PrgLocal;
                                }
                        StartAddressdtbootpquantum = 0x00FFF400;
                        Sizedtbootpquantum = 0xC00;
                        dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
                                &StartAddressdtbootpquantum,&Sizedtbootpquantum);
                        delete [] Prg;
                        }
                break;
                case Ctt_H8S2345_20MHZ: {
			dtbootp = new DataStreamPage32byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0x00FFF400;
			Sizedtbootpquantum = 0xC00;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
		case Ctt_H83048: {
			dtbootp = new DataStreamPage32byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0x00FFF300;
			Sizedtbootpquantum = 0xC00;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
//	  case Ctt_SH2MNJ600: {
//			unsigned int NumOfRecord = firmware->BootProgram.count();
//			Record* Prg = new Record[NumOfRecord];
//			for (unsigned int i = 0; i < NumOfRecord; i++) {
//				Record *PrgLocal;
//				PrgLocal = new Record(firmware->BootProgram.at(i));
//				Prg[i] = (*PrgLocal);
//				delete PrgLocal;
//				}
//			StartAddressdtbootpquantum = 0xFFFFF000;
//			Sizedtbootpquantum = 0xC00;
//			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
//				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
//			delete [] Prg;
//			}
//		break;
		case Ctt_H83687: {
			dtbootp = new DataStreamPage128byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xF780;
			Sizedtbootpquantum = 0x770;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
		case Ctt_H83687_10MHZ: {
			dtbootp = new DataStreamPage128byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xF780;
			Sizedtbootpquantum = 0x770;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
		case Ctt_H83687_16MHZ: {
			dtbootp = new DataStreamPage128byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xF780;
			Sizedtbootpquantum = 0x770;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		case Ctt_H836064_16MHZ: {
			dtbootp = new DataStreamPage128byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xF780;
			Sizedtbootpquantum = 0x6a0;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		case Ctt_H83687_16MHZ_BEN10: {
			dtbootp = new DataStreamPage128byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xF780;
			Sizedtbootpquantum = 0x770;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
		case Ctt_H83048FONE_16MHZ: {
			dtbootp = new DataStreamPage128byte(_8bit);
			unsigned int NumOfRecord = firmware->BootProgram.count();
			Record* Prg = new Record[NumOfRecord];
			for (unsigned int i = 0; i < NumOfRecord; i++) {
				Record *PrgLocal;
				PrgLocal = new Record(firmware->BootProgram.at(i));
				Prg[i] = (*PrgLocal);
				delete PrgLocal;
				}
			StartAddressdtbootpquantum = 0xFFF510;
			Sizedtbootpquantum = 0xA00;
			dtbootp->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofdtbootpquantum,
				&StartAddressdtbootpquantum,&Sizedtbootpquantum);
			delete [] Prg;
			}
		break;
		case Ctt_H8S2378_16MHZ: 
		case Ctt_SH27085_10MHZ:
		case Ctt_SH2A7286_12MHZ:{
			char devID[4];
			unsigned char clockmode;
			Command018Handler* cm = new Command018Handler(pDev);
			Res_t* pRes;
// --- Boot Status inquiry
			pRes = cm->ManageCommand(INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY);
			if (pRes) {
				if (pRes->Response == 0x5F) {
					fprintf(stdout,"Boot Program State:\r\n");
					fprintf(stderr,"\tStatus:0x%2x\r\n",pRes->body.N_BytesR.Data[0]);
					fprintf(stderr,"\tError:0x%2x\r\n",pRes->body.N_BytesR.Data[1]);
					}
				else {
					fprintf(stdout,"Errore nel comando di Boot Program state Inqury.\r\n");
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// FINE --- Boot Status inquiry
//
			pRes = cm->ManageCommand(INQ_SEL_CMD__SUPPORTED_DEVICE_INQUIRY);
			if (pRes) {
				char* tmp;
				tmp = new char[pRes->body.N_BytesR.Size + 16];
				if (!tmp) {delete cm; return false;}
				memset(tmp,0,pRes->body.N_BytesR.Size + 16);
				memcpy(tmp,pRes->body.N_BytesR.Data,4);
				memcpy(devID,pRes->body.N_BytesR.Data,4);
				fprintf(stdout,"Device Code - %s\r\n",tmp);
				memset(tmp,0,pRes->body.N_BytesR.Size + 16);
				memcpy(tmp,pRes->body.N_BytesR.Data + 4,pRes->body.N_BytesR.Size - 6);
				fprintf(stdout,"Product name - %s\r\n",tmp);
				delete tmp; tmp = 0;
				}
			else {delete cm; return false;}
// ---
//
			unsigned char devIDSize = 4;
			pRes = cm->ManageCommand(INQ_SEL_CMD__DEVICE_SELECTION,devID,&devIDSize);
			if (pRes) {
				if (pRes->Response == 0x06) fprintf(stdout,"device selection OK.\r\n");
				else {
					fprintf(stdout,"Errore nel comando di device selection.\r\n");
					fprintf(stderr,"Error:0x%2x\r\n",pRes->body.ErrorR.Err);
					fprintf(stderr,"Code:0x%2x\r\n",pRes->body.ErrorR.Code);
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// ---
//
			pRes = cm->ManageCommand(INQ_SEL_CMD__CLOCK_MODE_INQUIRY);
			if (pRes) {
				if (pRes->Response == 0x31) {
					fprintf(stderr,"# of Clock Mode:%d\r\n",pRes->body.N_BytesR.Data[0]);
					for (unsigned int i = 0; i < pRes->body.N_BytesR.Data[0]; i++) {
						fprintf(stderr,"Clock Mode-%d:0x%2x\r\n",i,pRes->body.N_BytesR.Data[i + 1]);
						}
					// ********* attenzione se ci sono piu' clock modes ************************
					clockmode = pRes->body.N_BytesR.Data[0];
					// ********* ************************************** ************************
					}
				else {
					fprintf(stdout,"Errore nel comando Clock mode inquiry.\r\n");
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// ---
//
			pRes = cm->ManageCommand(INQ_SEL_CMD__CLOCK_MODE_SELECTION,0,&clockmode);
			if (pRes) {
				if (pRes->Response == 0x06) fprintf(stdout,"clock mode selection OK.\r\n");
				else {
					fprintf(stdout,"Errore nel comando di device selection.\r\n");
					fprintf(stderr,"Error:0x%2x\r\n",pRes->body.ErrorR.Err);
					fprintf(stderr,"Code:0x%2x\r\n",pRes->body.ErrorR.Code);
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// ---
// --- Boot Status inquiry
			pRes = cm->ManageCommand(INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY);
			if (pRes) {
				if (pRes->Response == 0x5F) {
					fprintf(stdout,"Boot Program State:\r\n");
					fprintf(stderr,"\tStatus:0x%2x\r\n",pRes->body.N_BytesR.Data[0]);
					fprintf(stderr,"\tError:0x%2x\r\n",pRes->body.N_BytesR.Data[1]);
					}
				else {
					fprintf(stdout,"Errore nel comando di Boot Program state Inqury.\r\n");
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// FINE --- Boot Status inquiry
//
			pRes = cm->ManageCommand(INQ_SEL_CMD__MULTIPLICATION_RATIO_INQUIRY);
			if (pRes) {
				if (pRes->Response == 0x32) {
					unsigned int ptr = 0;
					unsigned int ed = pRes->body.N_BytesR.Data[ptr++];
					fprintf(stdout,"# of Clock Multipication Ratio types:%d\r\n",ed);
					for (unsigned int i = 0; i < ed; i++) {
						unsigned int end = pRes->body.N_BytesR.Data[ptr++];
						for (unsigned int j = 0; j < end; j++) {
							fprintf(stdout,"Clock Multipication Ratio %d: Mul Ratio - %d\r\n",j,pRes->body.N_BytesR.Data[ptr++]);
							}
						}
					}
				else {
					fprintf(stdout,"Errore nel comando Multiplication ratio inquiry.\r\n");
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// ---
//
			pRes = cm->ManageCommand(INQ_SEL_CMD__OP_CLOCK_FREQ_INQUIRY);
			if (pRes) {
				if (pRes->Response == 0x33) {
					unsigned int ptr = 0;
					unsigned int ed = pRes->body.N_BytesR.Data[ptr++];
					fprintf(stdout,"# of Operating Clock Frequency:%d\r\n",ed);
					for (unsigned int i = 0; i < ed; i++) {
						float tmp;
						tmp = (pRes->body.N_BytesR.Data[ptr++] * 256);
						tmp += pRes->body.N_BytesR.Data[ptr++];
						fprintf(stdout,"Minimum Operating Clock Frequency %d: Mul Ratio - %.2f MHZ\r\n",i,tmp / 100);
						tmp = (pRes->body.N_BytesR.Data[ptr++] * 256);
						tmp += pRes->body.N_BytesR.Data[ptr++];
						fprintf(stdout,"Maximum Operating Clock Frequency %d: Mul Ratio - %.2f MHZ\r\n",i,tmp / 100);
						}
					}
				else {
					fprintf(stdout,"Errore nel comando Operating Clock Frequency inquiry.\r\n");
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// ---
//
			pRes = cm->ManageCommand(INQ_SEL_CMD__USERMAT_INFO_INQUIRY);
			if (pRes) {
				unsigned char pI,pJ;
				fprintf(stdout,"Num of Areas: %d\r\n",pRes->body.N_BytesR.Data[0]);
				pI = 1; pJ = 5;
				for (unsigned int i = 0; i < (((unsigned int)(pRes->body.N_BytesR.Size - 1)) / 8); i++) {
					void* tmp = &(pRes->body.N_BytesR.Data[pI]);
					void* tmp1 = &(pRes->body.N_BytesR.Data[pJ]);
					fprintf(stdout,"Area-%d-SA: 0x%lx; Area-%d-LA: 0x%lx\r\n",
						i,
						lmirror(*((unsigned long*)tmp)),
						i,
						lmirror(*((unsigned long*)tmp1))
						);
					pI += 8; pJ += 8;
					}
				}
			else {delete cm; return false;}
// ---
// 
			pRes = cm->ManageCommand(INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY);
			if (pRes) {
				if (pRes->Response == 0x5F) {
					fprintf(stdout,"Boot Program State:\r\n");
					fprintf(stderr,"\tStatus:0x%2x\r\n",pRes->body.N_BytesR.Data[0]);
					fprintf(stderr,"\tError:0x%2x\r\n",pRes->body.N_BytesR.Data[1]);
					}
				else {
					fprintf(stdout,"Errore nel comando di Boot Program state Inqury.\r\n");
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// ---
//
			unsigned char bitrate[7];
			if (firmware->TargetCpu == Ctt_H8S2378_16MHZ) {
				bitrate[0] = 0x01; // 38400 / 100; 384 (0x0180) 
				bitrate[1] = 0x80;
				bitrate[2] = 0x06; //0x06; // Input Frequency 16 Mhz (1600 decine di KHz (0x0640))
				bitrate[3] = 0x40; 
				bitrate[4] = 0x01; //0x01; // Number of Multiplication Ratios
				bitrate[5] = 0x01; //0x01; // Operating
				bitrate[6] = 0x01; //0x01; // Peripheral
				}
			else if (firmware->TargetCpu == Ctt_SH27085_10MHZ) {
				bitrate[0] = 0x01; // 38400 / 100; 384 (0x0180) 
				bitrate[1] = 0x80;
				bitrate[2] = 0x03; //0x03; // Input Frequency 10 Mhz (1000 decine di KHz (0x03e0))
				bitrate[3] = 0xE8;
				bitrate[4] = 0x02; //0x02; // Number of Multiplication Ratios
				bitrate[5] = 0x02; //0x02; // Operating (Iphi) x 2 ( x 8 PLL / 4 default setting of the FREQ divider register)
				bitrate[6] = 0x02; //0x02; // Peripheral (Pphi) x 2 ( x 8 PLL / 4 default setting of the FREQ divider register)
				}
			else if (firmware->TargetCpu == Ctt_SH2A7286_12MHZ) {
				bitrate[0] = 0x01; //38400 / 100; 384 (0x0180)
				bitrate[1] = 0x80;
				bitrate[2] = 0x04; //0x04; // Input Frequency 12 Mhz (1200 decine di KHz (0x04B0))
				bitrate[3] = 0xB0;
				bitrate[4] = 0x01; //0x01; // Number of Multiplication Ratios
				bitrate[5] = 0x02; //0x02; // Operating (Iphi) x 2 ( x 8 PLL / 4 default setting of the FREQ divider register)
				bitrate[6] = 0x02; //0x02; // Peripheral (Pphi) x 2 ( x 8 PLL / 4 default setting of the FREQ divider register)
				}
			else {
				fprintf(stdout,"Cpu non supportata.\r\n");
				delete cm;
				return false;
				}
			pRes = cm->ManageCommand(INQ_SEL_CMD__NEW_BITRATE_SELECTION,bitrate);
			if (pRes) {
				if (pRes->Response == 0x06) fprintf(stdout,"New bitrate selection OK.\r\n");
				else {
					fprintf(stdout,"Errore nel comando di New bitrate selection.\r\n");
					fprintf(stderr,"Error:0x%2x\r\n",pRes->body.ErrorR.Err);
					fprintf(stderr,"Code:0x%2x\r\n",pRes->body.ErrorR.Code);
					delete cm; return false;
					}
				}
			else {delete cm; return false;}
// ---
			delete cm;
			}
		break;
	default: break;
	}

	__UI_OUTPUT("Trasmissione uploader in corso...");
	if ((firmware->TargetCpu == Ctt_H8S2378_16MHZ) ||
		(firmware->TargetCpu == Ctt_SH27085_10MHZ) ||
		(firmware->TargetCpu == Ctt_SH2A7286_12MHZ)) return true;

	Tx_Buffer[0] = (char) (dtbootp->GetBlock8Bit_ptr(0) >> 8);
	Tx_Buffer[1] = (char) (dtbootp->GetBlock8Bit_ptr(0));

	unsigned long countbyte = 0;
	do {
		pDev->PurgeTx();
		pDev->PurgeRx();
		if (!pDev->SendData(&(Tx_Buffer[countbyte]),1)) {
            __UI_OUTPUT("Errore trasmissione byte n.%d di eco Boot program",(int)countbyte);
			delete dtbootp;
            if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		if (!pDev->ReceiveData(&(Rx_Buffer[countbyte]),1)) {
            __UI_OUTPUT("Errore ricezione byte n.%d di eco Boot program",(int)countbyte);
			delete dtbootp;
            if (pDev) {delete pDev; pDev = 0;}
			return false;
			}

		countbyte++;
		} while (countbyte < 2);

	if ((Rx_Buffer[0] != Tx_Buffer[0]) || (Rx_Buffer[1] != Tx_Buffer[1])) {
            __UI_OUTPUT("Errore coerenza bytes di eco Boot program");
		delete dtbootp;
        if (pDev) {delete pDev; pDev = 0;}
		return false;
		}
// ------ fine trasmissione lunghezza boot program ----------------------------

// ------ inizio download boot program ----------------------------------------
	pDev->PurgeRx();
	pDev->PurgeTx();

	if (!dtbootp->SendByteFormBlock8bit(pDev,outDisplay,appl)) {
        __UI_OUTPUT(" Errore Invio pagine BootProgram");
        delete dtbootp;
        if (pDev) {delete pDev; pDev = 0;}
        return false;
        }
    __UI_OUTPUT("Trasmissione uploader OK.");
	return true;
}

bool arnSAParametric::DownloadTargetProgram(FirmwareDescr_t* pFirm)
{

    if (serInterfType == ci_None) return false;
    if (!strcmp(serInterfName,"")) return false;
    if (pDev) {delete pDev; pDev = 0;}
    portdef PComDef;
    strcpy(PComDef.portname,serInterfName);
    if (pFirm->TargetCpu == Ctt_H83687) PComDef.baudrate = 19200;
    else PComDef.baudrate = 38400;
    PComDef.databits = 8;
    PComDef.parity = 0;
    PComDef.stopbits = 1;
    PComDef.xon_xoff = false;
    PComDef.rts_cts = false;
    if ((pFirm->TargetCpu == Ctt_H8S2378_16MHZ) ||
        (pFirm->TargetCpu == Ctt_SH27085_10MHZ) ||
        (pFirm->TargetCpu == Ctt_SH2A7286_12MHZ)) PComDef.timeout = 100;
    else PComDef.timeout = 10;

    if (serInterfType == ci_COM) {
        if (!pDev) pDev = new arnComPort(PComDef);
        if (!pDev) return false;
        if (pDev->GetStatus() == 3) {
            __UI_OUTPUT("Porta COM occupata");
            if (pDev) {delete pDev; pDev = 0;}
            return false;
            }
        }
    else return false;

    __UI_OUTPUT("Trasmissione firmware in corso...");
    __PROCESS();
	if ((pFirm->TargetCpu != Ctt_H8S2378_16MHZ) &&
		(pFirm->TargetCpu != Ctt_SH27085_10MHZ) &&
		(pFirm->TargetCpu != Ctt_SH2A7286_12MHZ)) {
		/* Attendo SSSTart dal Micro */
		if (!ListenAndAnswerToEcu(ECU_SEARCH_PC,PC_DELEXTFLASH_ECU)) {
			__UI_OUTPUT("Errore ascolto comando SSStart");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		// Questo algoritmo mette a posto il problema dell' uscita dalla cancellazione
		// della flash esterna
		unsigned char SectCnt = 0;
		unsigned char ActSectCnt = SectCnt;
		bool triggerval = false;
		do {
			if (ListenAndAnswerToEcuForErasingSectors(ECU_DELOK_PC,PC_ERCNT_ECU,&SectCnt)){
				if (SectCnt > ActSectCnt) {
					__UI_OUTPUT("Settore n. %d cancellato.",SectCnt);
					ActSectCnt = SectCnt;
					}
				}
			else if (ListenAndAnswerToEcuForErasingSectors(ECU_DELNOT_PC,PC_EXIT_ECU,&SectCnt)) {
				__UI_OUTPUT("Errore cancellazione settore n.%d.",SectCnt);
				if (pDev) {delete pDev; pDev = 0;}
				return false;
				}
			else {
				__UI_OUTPUT("Timeout cancellazione settore n.%d.",SectCnt);
				if (pDev) {delete pDev; pDev = 0;}
				return false;
				}
			if (!triggerval) {if (SectCnt > ECU_DELOK_PC) triggerval = true;}
			if ((SectCnt == ECU_DELOK_PC) && triggerval) break;
			__PROCESS();
			} while (1/*SectCnt < (N_SECTORS - 1)*/);
		if (!ListenAndAnswerToEcu(ECU_DELOK_PC,PC_GODLD_ECU)) {
			__UI_OUTPUT("Errore ascolto fine cancellazione.");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		else __UI_OUTPUT("Fine Cancellazione Flash Esterna.");
		}

// ************* costruisco la lista dei record ******************************
	unsigned int NumOfRecord = pFirm->file.count();
	Record* Prg = new Record[NumOfRecord];
	for (unsigned int i = 0; i < NumOfRecord; i++) {
		Record *PrgLocal;
//		arnDebug("%s\n", pFirm->file.at(i));
		PrgLocal = new Record(pFirm->file.at(i));
		Prg[i] = (*PrgLocal);
		delete PrgLocal;
		}

	unsigned short numofUPpquantum;
	unsigned long StartAddressofQuantum[MAX_UP_QUANTUM_NUMBER];
	unsigned long SizeofQuantum[MAX_UP_QUANTUM_NUMBER];
	DataStream* dt = 0;
	switch (pFirm->TargetCpu) {
		case Ctt_SH27044:
			dt = new DataStreamPage32byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x20000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H8S2345:
			dt = new DataStreamPage32byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x20000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
                        break;
                case Ctt_H8S2345Z24E:
                        dt = new DataStreamPage32byte(_8bit);
                        numofUPpquantum = 1;
                        StartAddressofQuantum[0] = 0x00000000;
                        SizeofQuantum[0] = 0x20000;
                        dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
                        break;
                case Ctt_H8S2345_20MHZ:
			dt = new DataStreamPage32byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x20000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H83048:
			dt = new DataStreamPage32byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x20000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_SH27044F:
			dt = new DataStreamPage32byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x20000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
//		case Ctt_SH2MNJ600:
//			numofUPpquantum = 2;
//			StartAddressofQuantum[0] = 0x00000000;
//			SizeofQuantum[0] = 0x20000;
//			StartAddressofQuantum[1] = 0x00410000;
//			SizeofQuantum[1] = 0x20000;
//			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
//				StartAddressofQuantum,SizeofQuantum);
//			break;
//		case Ctt_MNJ600RAM:
//			numofUPpquantum = 1;
//			StartAddressofQuantum[0] = 0x00200000;
//			SizeofQuantum[0] = 0x10000;
//			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
//				StartAddressofQuantum,SizeofQuantum);
//			break;
		case Ctt_H83687:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0xe000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H83687_10MHZ:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0xe000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H83687_16MHZ:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0xe000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H836064_16MHZ:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x8000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H83687_16MHZ_BEN10:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0xe000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H83048FONE_16MHZ:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x20000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_H8S2378_16MHZ:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x80000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_SH27085_10MHZ:
			dt = new DataStreamPage128byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x80000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		case Ctt_SH2A7286_12MHZ:
			dt = new DataStreamPage256byte(_8bit);
			numofUPpquantum = 1;
			StartAddressofQuantum[0] = 0x00000000;
			SizeofQuantum[0] = 0x100000;
			dt->ConvFromRecordQuantum8bit(Prg,NumOfRecord,numofUPpquantum,
                        StartAddressofQuantum,SizeofQuantum);
			break;
		default: break;
		}

	if ((pFirm->TargetCpu != Ctt_H8S2378_16MHZ) &&
		(pFirm->TargetCpu != Ctt_SH27085_10MHZ) &&
		(firmware->TargetCpu != Ctt_SH2A7286_12MHZ)) {
		for (unsigned int i = 0; i < dt->GetpageNumber(); i++) {
			if (!dt->SendPage(pDev,i)) {
				__UI_OUTPUT("pagina %d di %d pagine. tentativi %d.   \r",i,(int)dt->GetpageNumber(),(int)dt->Getpagentwrite(i));
				__UI_OUTPUT("Errore 0x0006: Errore downloading user program. Riprovare.");
				delete dt;
				if (pDev) {delete pDev; pDev = 0;}
				return false;
				}
			else {
				if (dt->Getpagentwrite(i) != 0) {
					//StatRichEdit->Lines->Add(AnsiString("BAdrr: ") + AnsiString(IntToHex(((int)dt->Getpage32baseaddr(i)),6)) + AnsiString(" : ") + AnsiString(dt->Getpage32ntwrite(i)));
					__UI_OUTPUT("pagina %d di %d pagine. tentativi %d.   \r",i,(int)dt->GetpageNumber(),(int)dt->Getpagentwrite(i));
					__PROCESS();
					}
				}
			}
		if (!dt->SendEndSignal(pDev)) {
			__UI_OUTPUT("Errore 0x0006: Errore downloading user program. Riprovare.");
			delete dt;
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
		else __UI_OUTPUT("Trasmissione firmware OK.");
		}
	else {
		Res_t* pRes;
		Command018Handler* cm = new Command018Handler(pDev);
		if (!ListenAndAnswerToEcu(0x06,0x06)) {
			__UI_OUTPUT("Errore ricezione sincronizzazione cambio baudrate.\r\n");
			if (pDev) {delete pDev; pDev = 0;}
			return false;
			}
// --- Boot Status inquiry
		pRes = cm->ManageCommand(INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY);
		if (pRes) {
			if (pRes->Response == 0x5F) {
				__UI_OUTPUT("Boot Program State:\r\n");
				__UI_OUTPUT("\tStatus:0x%2x\r\n",pRes->body.N_BytesR.Data[0]);
				__UI_OUTPUT("\tError:0x%2x\r\n",pRes->body.N_BytesR.Data[1]);
				}
			else {
				__UI_OUTPUT("Errore nel comando di Boot Program state Inqury.\r\n");
				if (pDev) {delete pDev; pDev = 0;}
				delete cm; return false;
				}
			}
		else {delete cm; return false;}
// FINE --- Boot Status inquiry
//
		pRes = cm->ManageCommand(INQ_SEL_CMD__TRANS_TO_PROG_ERASE_STATE);
		if (pRes) {
			if (pRes->Response == 0x06) __UI_OUTPUT("Transition to Prog / Erase  OK.\r\n");
			else {
				__UI_OUTPUT("Errore nel comando di User MAT selection.\r\n");
				__UI_OUTPUT("Error:0x%2x\r\n",pRes->body.ErrorR.Err);
				__UI_OUTPUT("Code:0x%2x\r\n",pRes->body.ErrorR.Code);
				delete cm; return false;
				}
			}
		else {if (pDev) {delete pDev; pDev = 0;}delete cm; return false;}
// ---
// --- Boot Status inquiry
		pRes = cm->ManageCommand(INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY);
		if (pRes) {
			if (pRes->Response == 0x5F) {
				__UI_OUTPUT("Boot Program State:\r\n");
				__UI_OUTPUT("\tStatus:0x%2x\r\n",pRes->body.N_BytesR.Data[0]);
				__UI_OUTPUT("\tError:0x%2x\r\n",pRes->body.N_BytesR.Data[1]);
				}
			else {
				__UI_OUTPUT("Errore nel comando di Boot Program state Inqury.\r\n");
				if (pDev) {delete pDev; pDev = 0;}
				delete cm; return false;
				}
			}
		else {if (pDev) {delete pDev; pDev = 0;}delete cm; return false;}
// FINE --- Boot Status inquiry
//
		pRes = cm->ManageCommand(PRG_ERS_CMD__USER_MAT_PRG_SELECTION);
		if (pRes) {
			if (pRes->Response == 0x06) __UI_OUTPUT("User MAT Selection  OK.\r\n");
			else {
				__UI_OUTPUT("Errore nel comando di User MAT selection.\r\n");
				__UI_OUTPUT("Error:0x%2x\r\n",pRes->body.ErrorR.Err);
				__UI_OUTPUT("Code:0x%2x\r\n",pRes->body.ErrorR.Code);
				if (pDev) {delete pDev; pDev = 0;}
				delete cm; return false;
				}
			}
		else {if (pDev) {delete pDev; pDev = 0;}delete cm; return false;}

// --- Boot Status inquiry
		pRes = cm->ManageCommand(INQ_SEL_CMD__BOOTPROGRAM_STATUS_INQUIRY);
		if (pRes) {
			if (pRes->Response == 0x5F) {
				__UI_OUTPUT("Boot Program State:\r\n");
				__UI_OUTPUT("\tStatus:0x%2x\r\n",pRes->body.N_BytesR.Data[0]);
				__UI_OUTPUT("\tError:0x%2x\r\n",pRes->body.N_BytesR.Data[1]);
				fprintf(stdout,"Boot Program State:\r\n");
				fprintf(stderr,"\tStatus:0x%2x\r\n",pRes->body.N_BytesR.Data[0]);
				fprintf(stderr,"\tError:0x%2x\r\n",pRes->body.N_BytesR.Data[1]);
				}
			else {
				__UI_OUTPUT("Errore nel comando di Boot Program state Inqury.\r\n");
				fprintf(stdout,"Errore nel comando di Boot Program state Inqury.\r\n");
				if (pDev) {delete pDev; pDev = 0;}
				delete cm; return false;
				}
			}
		else {delete cm; return false;}
// FINE --- Boot Status inquiry

		unsigned short ProgPageLen = 0;
		switch (firmware->TargetCpu) {
			case Ctt_H8S2378_16MHZ: ProgPageLen = 128; break;
			case Ctt_SH27085_10MHZ: ProgPageLen = 128; break;
			case Ctt_SH2A7286_12MHZ: ProgPageLen = 256; break;
			default: ProgPageLen = 32; break;
			};
		for (unsigned int i = 0; i < dt->GetpageNumber(); i++) {
			if (dt->IsDummyPage(i)) continue;
			pRes = cm->WritePage(dt->Getpagebaseaddr(i),dt->Getpagedata(i),ProgPageLen);
			if (pRes) {
				if (pRes->Response == 0x06) {__UI_OUTPUT("page %d of %d - Write OK.\r\n",(int)i,(int)dt->GetpageNumber());if (!(i%32)) {__PROCESS();}}
				else {
					__UI_OUTPUT("Errore nel comando di Write Page.\r\n");
					__UI_OUTPUT("Error:0x%2x\r\n",pRes->body.ErrorR.Err);
					__UI_OUTPUT("Code:0x%2x\r\n",pRes->body.ErrorR.Code);
					if (pDev) {delete pDev; pDev = 0;}
					delete cm; return false;
					}
				}
			else {
				__UI_OUTPUT("Errore nel comando di Write Page.\r\n");
				if (pDev) {delete pDev; pDev = 0;}
				delete cm; return false;
				}
			}
// ---
		__UI_OUTPUT("Trasmissione firmware OK.");
		__PROCESS();
		delete cm;
		}
	delete dt;
	if (pDev) {delete pDev; pDev = 0;}
	return true;
}

//---------------------------------------------------------------------------
bool arnSAParametric::ListenAndAnswerToEcu(unsigned char LstCmd,unsigned char AswCmd)
{
	char Rx_Buf[10] = {0,0,0,0,0,0,0,0,0,0};
	char Tx_Buf[10] = {0,0,0,0,0,0,0,0,0,0};

	int cerr;
	bool ReceiveOk;
	if ((firmware->TargetCpu != Ctt_H8S2378_16MHZ) &&
		(firmware->TargetCpu != Ctt_SH27085_10MHZ) &&
		(firmware->TargetCpu != Ctt_SH2A7286_12MHZ)) {
		cerr = 10;
		do {
			pDev->PurgeRx();
			Rx_Buf[0] = 0x00;
			ReceiveOk = pDev->ReceiveData(&(Rx_Buf[0]),1);
			if (!ReceiveOk) continue;
			} while ((Rx_Buf[0] != ((char) LstCmd)) && (--cerr));
		if ((!cerr) || (!ReceiveOk)) return false;
		pDev->PurgeTx();
		Tx_Buf[0] = (char) AswCmd;
		pDev->PurgeRx();
		if (!pDev->SendData(&(Tx_Buf[0]),1)) return false;
		}
	else {
		pDev->PurgeTx();
		pDev->PurgeRx();
		Tx_Buf[0] = (char) AswCmd;
		if (!pDev->SendData(&(Tx_Buf[0]),1)) return false;
		cerr = 10;
		do {
			Rx_Buf[0] = 0x00;
			ReceiveOk = pDev->ReceiveData(&(Rx_Buf[0]),1);
			if (!ReceiveOk) continue;
			} while ((Rx_Buf[0] != ((char) LstCmd)) && (cerr--));
		if ((!cerr) || (!ReceiveOk)) return false;
		return true;
		}
	return true;
}
//---------------------------------------------------------------------------
bool arnSAParametric::ListenAndAnswerToEcuForErasingSectors(unsigned char LstCmd,unsigned char AswCmd,unsigned char* Sect)
{
	char Rx_Buf[10] = {0,0,0,0,0,0,0,0,0,0};
	char Tx_Buf[10] = {0,0,0,0,0,0,0,0,0,0};
    int cerr;
    bool ReceiveOk;

    cerr = 50;
    do {
        pDev->PurgeRx();
        Rx_Buf[0] = Rx_Buf[1]= 0x00;
        ReceiveOk = pDev->ReceiveData(&(Rx_Buf[0]),1);
        /*ReceiveOk = */pDev->ReceiveData(&(Rx_Buf[1]),1);
        if (!ReceiveOk) continue;
        } while ((Rx_Buf[0] != ((char) LstCmd)) && (--cerr));
    if ((!cerr) || (!ReceiveOk)) {
        arnDebug("0x%2x;0x%2x\n",LstCmd,AswCmd);
        arnDebug("0x%2x;0x%2x\n",Rx_Buf[0],Rx_Buf[1]);
        __UI_OUTPUT("cerr = %d, ReceiveOk = %d.\r\n",cerr,ReceiveOk); return false;
    }

	pDev->PurgeTx();
	Tx_Buf[0] = (char) AswCmd;
	pDev->PurgeRx();
	if (!pDev->SendData(&(Tx_Buf[0]),1)) {__UI_OUTPUT("%s,%s,%d.\r\n",__FILE__,__FUNCTION__,__LINE__); return false;}
	*Sect = Rx_Buf[1];
	return true;
}






















//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// NOTA riguardo la classe Record
// i record di dati possono avere la seguente forma:
//
//               2 * ToNum(xx)
//           _______________
//	S1xxyyyyaabb...zzcc
//               _________
//                2*(ToNum(xx) - 3)
//
//               2 * ToNum(xx)
//           _________________
//	S2xxyyyyyyaabb...zzcc
//               ___________
//                2*(ToNum(xx) - 4)
//
//               2 * ToNum(xx)
//           ___________________
//	S3xxyyyyyyyyaabb...zzcc
//               _____________
//                2*(ToNum(xx) - 5)
//
//	xx = numero di byte; yyyy = indirizzo; aabb...zz = bytes dei dati; cc = checksum
//-----------------------------------------------------------------------------
// debug 		fprintf(stdout,"%s,%s,%d.\r\n",__FILE__,__FUNCTION__,__LINE__);
//-----------------------------------------------------------------------------
// Questa versione e' stata fatta per lavorare con multi quanti.

Record::Record(void)
{
Tipo = NONE;
NumOfByte = 0;
BaseAddr = 0;
NumOfData = 0;
Data = NULL;
CheckSum = 0;
}
//-----------------------------------------------------------------------------
Record::~Record(void)
{
if (Data != NULL)
   {
   delete Data;
   Data = NULL;
   }
}
//-----------------------------------------------------------------------------
Record::Record(const QString& Str)
{
    QString App,S0,S1,S2,S3,S7,S8,S9;
    S0 = "S0"; //S0.Push('S');S0.Push('0');S0.Push('\0');
    S1 = "S1"; //S1.Push('S');S1.Push('1');S1.Push('\0');
    S2 = "S2"; //S2.Push('S');S2.Push('2');S2.Push('\0');
    S3 = "S3"; //S3.Push('S');S3.Push('3');S3.Push('\0');
    S7 = "S7"; //S7.Push('S');S7.Push('7');S7.Push('\0');
    S8 = "S8"; //S8.Push('S');S8.Push('8');S8.Push('\0');
    S9 = "S9"; //S9.Push('S');S9.Push('9');S9.Push('\0');

    App = Str.mid(0,2);

    QString AddrType(App);

    if (App == S0) Tipo = HEADER;
    else if ((App == S2) || (App == S1) || (App == S3)) Tipo = DATA;   // S1 0x0000 0xffff , S2 0x010000 0x1ffff , S3 0xFFFFFFFF
    else if ((App == S7) || (App == S8) || (App == S9)) Tipo = FINAL;
    else Tipo = NONE;

    App = "";
    App = Str.mid(2,2);

    char tc2[3]; strcpy(tc2,App.toLatin1().constData());
    NumOfByte = (unsigned char) atolh((char*)tc2);

    if (AddrType == S1) NumOfData = (unsigned char) (NumOfByte - 3);
    else if (AddrType == S2) NumOfData = (unsigned char) (NumOfByte - 4);
    else if (AddrType == S3) NumOfData = (unsigned char) (NumOfByte - 5);
    else NumOfData = (unsigned char) (0);

    Data = new unsigned char[NumOfData];

    if (AddrType == S1) {
        App = "";
        App = Str.mid(4,4);
        char tc4[5]; strcpy(tc4,App.toLatin1().constData());
        BaseAddr = (unsigned long) atolh((char*)tc4);
        int i;
        for (i = 0; i < NumOfData; i++) {
            App = "";
            App += Str[8 + (i * 2)];
            App += Str[8 + (i * 2) + 1];
            strcpy(tc2,App.toLatin1().constData());
            Data[i] = (unsigned char) atolh((char*)tc2);
            }
        App = "";
        App += Str[8 + (i * 2)];
        App += Str[8 + (i * 2) + 1];
        strcpy(tc2,App.toLatin1().constData());
        CheckSum = (unsigned char) atolh((char*)tc2);
        }
    else if (AddrType == S2) {
        App = "";
        App = Str.mid(4,6);
        char tc6[7]; strcpy(tc6,App.toLatin1().constData());
        BaseAddr = (unsigned long) atolh((char*)tc6);
        int i;
        for (i = 0; i < NumOfData; i++) {
            App = "";
            App += Str[10 + (i * 2)];
            App += Str[10 + (i * 2) + 1];
            strcpy(tc2,App.toLatin1().constData());
            Data[i] = (unsigned char) atolh((char*)tc2);
            }

        App = "";
        App += Str[10 + (i * 2)];
        App += Str[10 + (i * 2) + 1];
        strcpy(tc2,App.toLatin1().constData());
        CheckSum = (unsigned char) atolh((char*)tc2);
        }
    else if (AddrType == S3) {
        App = "";
        App = Str.mid(4,8);
        char tc8[9]; strcpy(tc8,App.toLatin1().constData());
        BaseAddr = (unsigned long) atolh((char*)tc8);
        int i;
        for (i = 0; i < NumOfData; i++) {
            App = "";
            App += Str[12 + (i * 2)];
            App += Str[12 + (i * 2) + 1];
            strcpy(tc2,App.toLatin1().constData());
            Data[i] = (unsigned char) atolh((char*)tc2);
            }

        App = "";
        App += Str[12 + (i * 2)];
        App += Str[12 + (i * 2) + 1];
        strcpy(tc2,App.toLatin1().constData());
        CheckSum = (unsigned char) atolh((char*)tc2);
        }
}
//-----------------------------------------------------------------------------
Record& Record::operator =(const Record& R)
{
Tipo = R.Tipo;
NumOfByte = R.NumOfByte;
BaseAddr = R.BaseAddr;
NumOfData = R.NumOfData;
if (Data != NULL)
   {
   delete Data;
   Data = NULL;
   }

Data = new unsigned char[NumOfData];
for (int i = 0; i < NumOfData; i++)
    Data[i] = R.Data[i];
CheckSum = R.CheckSum;

return (*this);
}
//-----------------------------------------------------------------------------
bool Record::SendRecord(arnSerialInterface *HPt)
{
if (Tipo == DATA)
   {
   char Tx_Buffer[64],Rx_Buffer[64];

   Tx_Buffer[0] = (char) ('P');
   Tx_Buffer[1] = (char) ((unsigned char) (NumOfData + 5));
   HPt->PurgeRx();
   HPt->PurgeTx();
   if (!HPt->SendData(Tx_Buffer,2))
      return false;
   if (!HPt->ReceiveData(Rx_Buffer,1))
      return false;
   if (Rx_Buffer[0] != 'K')
          return false;

   Tx_Buffer[2] = (char) ((BaseAddr & 0xFF000000) >> 24);
   Tx_Buffer[3] = (char) ((BaseAddr & 0x00FF0000) >> 16);
   Tx_Buffer[4] = (char) ((BaseAddr & 0x0000FF00) >> 8);
   Tx_Buffer[5] = (char) ((BaseAddr & 0x000000FF));

   for (int i = 0; i < NumOfData; i++)
       Tx_Buffer[6 + i] = (char) (Data[i]);

  Tx_Buffer[6 + NumOfData] = 0;
  for (unsigned char count = 0; count < (NumOfData + 6); count++)
      Tx_Buffer[6 + NumOfData] += Tx_Buffer[count];

  HPt->PurgeRx();
  HPt->PurgeTx();
  if (!HPt->SendData((Tx_Buffer + 2),(NumOfData + 5)))
          return false;
  while(!HPt->ReceiveData(Rx_Buffer,1));
  if (Rx_Buffer[0] != 0x03)
     return false;
  }
else if (Tipo == FINAL)
   {
   char Tx_Buffer[2],Rx_Buffer[2];
   // ******** record finale E0xFF
   Tx_Buffer[0] = (char) ('E');
   Tx_Buffer[1] = (char) (0xFF);

   HPt->PurgeRx();
   HPt->PurgeTx();
   if (!HPt->SendData(Tx_Buffer,2))
      return false;
   if (!HPt->ReceiveData(Rx_Buffer,1))
      return false;
   if (Tx_Buffer[0] != Rx_Buffer[0])
      return false;

   }
else if (Tipo == HEADER)
   return false;
else if (Tipo == NONE)
   return false;

return true;
}
//-----------------------------------------------------------------------------
bool Record::SendData(arnSerialInterface *HPt)
{
char Tx_Buffer,Rx_Buffer;

for (int i = 0; i < NumOfData; i++)
    {
    Tx_Buffer = (char) (Data[i]);
    HPt->PurgeRx();
    HPt->PurgeTx();
    if (!HPt->SendData(&Tx_Buffer,1))
       return false;

    if (!HPt->ReceiveData(&Rx_Buffer,1))
       return false;

    if (Tx_Buffer != Rx_Buffer)
       return false;
    }
return true;
}
//-----------------------------------------------------------------------------





















DataStream::DataStream(targetdatasize_t datasize, targetpagesize_t pagesize)
{
	targetdatasize = datasize;
	targetpagesize = pagesize;
	numofquantum = 0;
	Block8bit = NULL;
}

DataStream::~DataStream(void)
{
	if (Block8bit != NULL) {
		for (unsigned short i = 0; i < numofquantum; i++) if (Block8bit[i]->Data != NULL) delete [] Block8bit[i]->Data;
		delete [] Block8bit;
		Block8bit = 0;
		}
}


bool DataStream::SendByteFormBlock8bit(arnSerialInterface *HPt, QStatusBar* outD ,QApplication* app)
{
	char Tx_Buffer,Rx_Buffer;
	for (unsigned short v = 0; v < numofquantum; v++) {
		if (Block8bit[v]->ptr > Block8bit[v]->Size) Block8bit[v]->ptr = Block8bit[v]->Size;
		for (unsigned long i = 0; i < Block8bit[v]->ptr; i++) {
			Tx_Buffer = (char) (Block8bit[v]->Data[i]);
			HPt->PurgeRx();
			HPt->PurgeTx();
			if (!HPt->SendData(&Tx_Buffer,1)) return false;
			if (!HPt->ReceiveData(&Rx_Buffer,1)) return false;
			if (Tx_Buffer != Rx_Buffer) return false;
			if (outD) {
				QString uioutbff;
				uioutbff.sprintf("Boot Program: byte %d di %d .",int(i),int(Block8bit[v]->ptr));
				outD->showMessage(uioutbff);
				}
			if (app) app->processEvents();
			}
		}
	return true;
}


































//BEGIN pagine 32 bytes
DataStreamPage32byte::DataStreamPage32byte(targetdatasize_t datasize)
	: DataStream(datasize,_tps32)
{
	page32bytesNumber  = 0;
	pages = NULL;
}

DataStreamPage32byte::~DataStreamPage32byte(void)
{
	if (pages) delete [] pages;
	pages = NULL;
	page32bytesNumber  = 0;
}

bool DataStreamPage32byte::ConvFromRecordQuantum8bit(Record* RecArr,int RecArrSize,
                unsigned short numofquan,
                unsigned long* startaddr_arr,
                unsigned long* size_arr)
{
	unsigned long* startaddr_array;
	unsigned long* size_array;

	if ((numofquan < 1) || (!startaddr_arr) || (!size_arr)) throw ("DataStream: Error in constructor parameter definition");
	numofquantum = numofquan;
	startaddr_array = new unsigned long [numofquantum];
	if (!startaddr_array) throw ("DataStream: startaddr_array : Error in constructor parameter allocation");
	size_array = new unsigned long [numofquantum];
	if (!size_array) throw ("DataStream: size_array : Error in constructor parameter allocation");
	for (unsigned short i = 0; i < numofquantum; i++) {
		startaddr_array[i] = startaddr_arr[i];
		size_array[i] = size_arr[i];
		page32bytesNumber +=  (size_array[i] / PAGESIZE32);
		}
	Block8bit = NULL;
//   page32bytesNumber  = PAGESNUMBER;
	switch (targetdatasize) {
		case _8bit:
			Block8bit = new quantum8bit_t*[numofquantum];
			if (!Block8bit) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
        		for (unsigned short i = 0; i < numofquantum; i++) {
        			Block8bit[i] = new quantum8bit_t();
        			if (!Block8bit[i]) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
        			Block8bit[i]->BaseAddr = startaddr_array[i];
        			Block8bit[i]->Size = size_array[i];
        			Block8bit[i]->Data = new unsigned char[Block8bit[i]->Size];
        			if (!Block8bit[i]->Data) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
        			Block8bit[i]->ptr = 0;
        			for (unsigned long j = 0; j < Block8bit[i]->Size; j++)  Block8bit[i]->Data[j] = 0xFF;
        			}
        		break;
		default : break;
		}
	if (startaddr_array) delete [] startaddr_array;
	if (size_array) delete [] size_array;


	unsigned long Off = 0 ;
	unsigned long BAddr = 0;
	RecordArricchito* RecL = new  RecordArricchito();
	if (!RecL) throw ("DataStream: RecL : Error in constructor parameter allocation");
	for (int i = 0; i < RecArrSize; i++) {
		(*((Record*)RecL)) = RecArr[i];
		BAddr = RecL->GetBaseAddr();
		for (unsigned short v = 0; v < numofquantum; v++) {
			if ((BAddr >= Block8bit[v]->BaseAddr) && (((double)BAddr) < (((double)(Block8bit[v]->BaseAddr)) + Block8bit[v]->Size))) {
				Off = BAddr - Block8bit[v]->BaseAddr;
				if ((Off > Block8bit[v]->Size) || (RecL->GetTipo() != DATA)) continue;
				for (int j = 0; j <  RecL->GetNumOfData(); j++)
					if ((Off + j) <= Block8bit[v]->Size) {
						Block8bit[v]->Data[Off + j] = RecL->GetData((unsigned char)j);
						Block8bit[v]->ptr = Off + j;
						}
				Block8bit[v]->ptr++;
				break;
				}
			}
		}

	unsigned long acc = 0;//Block8bit[0]->BaseAddr;
	pages = new page32bytes[page32bytesNumber];
	if (!pages) throw ("DataStream: pages : Error in constructor parameter allocation");
	for (unsigned long i = 0; i < page32bytesNumber;) {
		pages[i].Addr = acc;
		for (unsigned short v = 0; v < numofquantum; v++) {
			if ((pages[i].Addr >= Block8bit[v]->BaseAddr) && (((double)(pages[i].Addr)) < (((double)(Block8bit[v]->BaseAddr)) + Block8bit[v]->Size))) {
				for (int j = 0; j < PAGESIZE32; j++) pages[i].Data[j] = Block8bit[v]->Data[acc - Block8bit[v]->BaseAddr + j];
				acc += PAGESIZE32;
				i++;
				break;
				}
			else if (pages[i].Addr < Block8bit[v]->BaseAddr) {
				acc = Block8bit[v]->BaseAddr;
				}
			}
		}
	delete RecL;
	return true;
}

bool DataStreamPage32byte::IsDummyPage(unsigned long Num)
{
	for (int i = 0; i < PAGESIZE32; i++) if (pages[Num].Data[i] != 0xFF) return false;
	return true;
}

bool DataStreamPage32byte::SendPage(arnSerialInterface *HPt, unsigned long Num)
{
	pages[Num].ntwrite = 0;
	if (IsDummyPage(Num)) return true;

	char Tx_Buffer[64],Rx_Buffer[64];

	Tx_Buffer[0] = (char) ('P');
	Tx_Buffer[1] = (char) ((unsigned char) (PAGESIZE32 + 5));
	HPt->PurgeRx();
	HPt->PurgeTx();
	if (!HPt->SendData(Tx_Buffer,2)) {return false;}

	if (!HPt->ReceiveData(Rx_Buffer,1)) {
		return false;
		}
	if (Rx_Buffer[0] != 'K') {return false;}

	Tx_Buffer[2] = (char) ((pages[Num].Addr & 0xFF000000) >> 24);
	Tx_Buffer[3] = (char) ((pages[Num].Addr & 0x00FF0000) >> 16);
	Tx_Buffer[4] = (char) ((pages[Num].Addr & 0x0000FF00) >> 8);
	Tx_Buffer[5] = (char) ((pages[Num].Addr & 0x000000FF));
//	test test test
//	if (pages[Num].Addr ==0x00410000) {
//		unsigned char ppp= 0;
//		ppp++;
//		}

	for (int i = 0; i < PAGESIZE32; i++) Tx_Buffer[6 + i] = (char) (pages[Num].Data[i]);

	Tx_Buffer[6 + PAGESIZE32] = 0;
	for (unsigned char count = 0; count < (PAGESIZE32 + 6); count++) Tx_Buffer[6 + PAGESIZE32] += Tx_Buffer[count];

	HPt->PurgeRx();
	HPt->PurgeTx();
	if (!HPt->SendData((Tx_Buffer + 2),(PAGESIZE32 + 5))) {return false;}
	Rx_Buffer[0] = 0;
	unsigned char cntt = 3;
 	while((Rx_Buffer[0] != ((char)ADDROUTOFRANGE)) &&
		(Rx_Buffer[0] != ((char)PRGNOTPAGE)) &&
		(Rx_Buffer[0] != ((char)PRGOKPAGE)) &&
		(Rx_Buffer[0] != 'C') &&
		(cntt)
		) {
		if (HPt->ReceiveData(Rx_Buffer,1)) {
		/*if ((Rx_Buffer[0] != ((char)PRGNOTPAGE)) &&
			(Rx_Buffer[0] != ((char)PRGOKPAGE))&&
			(Rx_Buffer[0] != 'C') &&
			(Rx_Buffer[0] != ((char)ADDROUTOFRANGE))
			) pages[Num].ntwrite = Rx_Buffer[0];
		*/
			if (Rx_Buffer[0] == 'N') {
				if (HPt->ReceiveData(Rx_Buffer + 1,1)) {
					if (Rx_Buffer[1] == 'T') {
						if (HPt->ReceiveData(Rx_Buffer + 2,1)) {
							pages[Num].ntwrite = Rx_Buffer[2];
							}
						}
					}
				}
			}
		else cntt--;
		}
	if ((!cntt) || (Rx_Buffer[0] == 'C') || (((unsigned char) Rx_Buffer[0]) == PRGNOTPAGE)) {return false;}
	else if (((unsigned char) Rx_Buffer[0]) == ADDROUTOFRANGE) {
		HPt->ReceiveData(Rx_Buffer + 1,4);
		return false;
		}
	return true;
}


bool DataStreamPage32byte::SendEndSignal(arnSerialInterface *HPt)
{
   char Tx_Buffer[2],Rx_Buffer[2];
   // ******** record finale E0xFF
   Tx_Buffer[0] = (char) ('E');
   Tx_Buffer[1] = (char) (0xFF);

   HPt->PurgeRx();
   HPt->PurgeTx();
   if (!HPt->SendData(Tx_Buffer,2)) return false;
   if (!HPt->ReceiveData(Rx_Buffer,1)) return false;
   if (Tx_Buffer[0] != Rx_Buffer[0]) return false;
   return true;
}
//END pagine 32 bytes


//BEGIN pagine 128 bytes
DataStreamPage128byte::DataStreamPage128byte(targetdatasize_t datasize)
	: DataStream(datasize,_tps128)
{
	page128bytesNumber  = 0;
	pages = NULL;
}

DataStreamPage128byte::~DataStreamPage128byte(void)
{
	if (pages) delete [] pages;
	pages = NULL;
	page128bytesNumber  = 0;
}

bool DataStreamPage128byte::ConvFromRecordQuantum8bit(Record* RecArr,int RecArrSize,
                unsigned short numofquan,
                unsigned long* startaddr_arr,
                unsigned long* size_arr)
{
	unsigned long* startaddr_array;
	unsigned long* size_array;

	if ((numofquan < 1) || (!startaddr_arr) || (!size_arr)) throw ("DataStream: Error in constructor parameter definition");
	numofquantum = numofquan;
	startaddr_array = new unsigned long [numofquantum];
	if (!startaddr_array) throw ("DataStream: startaddr_array : Error in constructor parameter allocation");
	size_array = new unsigned long [numofquantum];
	if (!size_array) throw ("DataStream: size_array : Error in constructor parameter allocation");
	for (unsigned short i = 0; i < numofquantum; i++) {
		startaddr_array[i] = startaddr_arr[i];
		size_array[i] = size_arr[i];
		page128bytesNumber +=  (size_array[i] / PAGESIZE128);
		}
	Block8bit = NULL;
//   page128bytesNumber  = PAGESNUMBER;
	switch (targetdatasize) {
		case _8bit:
			Block8bit = new quantum8bit_t*[numofquantum];
			if (!Block8bit) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
        		for (unsigned short i = 0; i < numofquantum; i++) {
        			Block8bit[i] = new quantum8bit_t();
        			if (!Block8bit[i]) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
        			Block8bit[i]->BaseAddr = startaddr_array[i];
        			Block8bit[i]->Size = size_array[i];
        			Block8bit[i]->Data = new unsigned char[Block8bit[i]->Size];
        			if (!Block8bit[i]->Data) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
        			Block8bit[i]->ptr = 0;
        			for (unsigned long j = 0; j < Block8bit[i]->Size; j++)  Block8bit[i]->Data[j] = 0xFF;
        			}
        		break;
		default : break;
		}
	if (startaddr_array) delete [] startaddr_array;
	if (size_array) delete [] size_array;


	unsigned long Off = 0 ;
	unsigned long BAddr = 0;
	RecordArricchito* RecL = new  RecordArricchito();
	if (!RecL) throw ("DataStream: RecL : Error in constructor parameter allocation");
	for (int i = 0; i < RecArrSize; i++) {
		(*((Record*)RecL)) = RecArr[i];
		BAddr = RecL->GetBaseAddr();
		for (unsigned short v = 0; v < numofquantum; v++) {
			if ((BAddr >= Block8bit[v]->BaseAddr) && (((double)BAddr) < (((double)(Block8bit[v]->BaseAddr)) + Block8bit[v]->Size))) {
				Off = BAddr - Block8bit[v]->BaseAddr;
				if ((Off > Block8bit[v]->Size) || (RecL->GetTipo() != DATA)) continue;
				for (int j = 0; j <  RecL->GetNumOfData(); j++)
					if ((Off + j) <= Block8bit[v]->Size) {
						Block8bit[v]->Data[Off + j] = RecL->GetData((unsigned char)j);
						Block8bit[v]->ptr = Off + j;
						}
				Block8bit[v]->ptr++;
				break;
				}
			}
		}
	unsigned long acc = 0;//Block8bit[0]->BaseAddr;
	pages = new page128bytes[page128bytesNumber];
	if (!pages) throw ("DataStream: pages : Error in constructor parameter allocation");
	for (unsigned long i = 0; i < page128bytesNumber;) {
		pages[i].Addr = acc;
		for (unsigned short v = 0; v < numofquantum; v++) {
			if ((pages[i].Addr >= Block8bit[v]->BaseAddr) && (((double)(pages[i].Addr)) < (((double)(Block8bit[v]->BaseAddr)) + Block8bit[v]->Size))) { // somma maggiore di 0xffffffff
				for (int j = 0; j < PAGESIZE128; j++) pages[i].Data[j] = Block8bit[v]->Data[acc - Block8bit[v]->BaseAddr + j];
				acc += PAGESIZE128;
				i++;
				break;
				}
			else if (pages[i].Addr < Block8bit[v]->BaseAddr)
				acc = Block8bit[v]->BaseAddr;
			}
		}
	delete RecL;
	return true;
}

bool DataStreamPage128byte::IsDummyPage(unsigned long Num)
{
	for (int i = 0; i < PAGESIZE128; i++) if (pages[Num].Data[i] != 0xFF) return false;
	return true;
}

bool DataStreamPage128byte::SendPage(arnSerialInterface *HPt,unsigned long Num)
{
	pages[Num].ntwrite = 0;
	if (IsDummyPage(Num)) return true;

	char Tx_Buffer[512],Rx_Buffer[64];

	Tx_Buffer[0] = (char) ('P');
	Tx_Buffer[1] = (char) ((unsigned char) (PAGESIZE128 + 5));
	HPt->PurgeRx();
	HPt->PurgeTx();
	if (!HPt->SendData(Tx_Buffer,2)) {
		return false;
		}

	if (!HPt->ReceiveData(Rx_Buffer,1)) {
		return false;
		}
	if (Rx_Buffer[0] != 'K') {
		return false;
		}

	Tx_Buffer[2] = (char) ((pages[Num].Addr & 0xFF000000) >> 24);
	Tx_Buffer[3] = (char) ((pages[Num].Addr & 0x00FF0000) >> 16);
	Tx_Buffer[4] = (char) ((pages[Num].Addr & 0x0000FF00) >> 8);
	Tx_Buffer[5] = (char) ((pages[Num].Addr & 0x000000FF));
//	test test test
//	if (pages[Num].Addr ==0x00410000) {
//		unsigned char ppp= 0;
//		ppp++;
//		}

	for (int i = 0; i < PAGESIZE128; i++) Tx_Buffer[6 + i] = (char) (pages[Num].Data[i]);

	Tx_Buffer[6 + PAGESIZE128] = 0;
	for (unsigned char count = 0; count < (PAGESIZE128 + 6); count++) Tx_Buffer[6 + PAGESIZE128] += Tx_Buffer[count];

	HPt->PurgeRx();
	HPt->PurgeTx();
	if (!HPt->SendData((Tx_Buffer + 2),(PAGESIZE128 + 5))) {
		return false;
		}
	Rx_Buffer[0] = 0;
	unsigned char cntt = 3;
 	while((Rx_Buffer[0] != ((char)ADDROUTOFRANGE)) &&
		(Rx_Buffer[0] != ((char)PRGNOTPAGE)) &&
		(Rx_Buffer[0] != ((char)PRGOKPAGE)) &&
		(Rx_Buffer[0] != 'C') &&
		(cntt)
		) {
		if (HPt->ReceiveData(Rx_Buffer,1)) {
		/*if ((Rx_Buffer[0] != ((char)PRGNOTPAGE)) &&
			(Rx_Buffer[0] != ((char)PRGOKPAGE))&&
			(Rx_Buffer[0] != 'C') &&
			(Rx_Buffer[0] != ((char)ADDROUTOFRANGE))
			) pages[Num].ntwrite = Rx_Buffer[0];
		*/
			if (Rx_Buffer[0] == 'N') {
				if (HPt->ReceiveData(Rx_Buffer + 1,1)) {
					if (Rx_Buffer[1] == 'T') {
						if (HPt->ReceiveData(Rx_Buffer + 2,1)) {
							pages[Num].ntwrite = Rx_Buffer[2];
							}
						}
					}
				}
			}
		else cntt--;
		}
	if ((!cntt) || (Rx_Buffer[0] == 'C') || (((unsigned char) Rx_Buffer[0]) == PRGNOTPAGE)) {
		return false;
		}
	else if (((unsigned char) Rx_Buffer[0]) == ADDROUTOFRANGE) {
		HPt->ReceiveData(Rx_Buffer + 1,4);
		return false;
		}
	return true;
}


bool DataStreamPage128byte::SendEndSignal(arnSerialInterface *HPt)
{
   char Tx_Buffer[2],Rx_Buffer[2];
   // ******** record finale E0xFF
   Tx_Buffer[0] = (char) ('E');
   Tx_Buffer[1] = (char) (0xFF);

   HPt->PurgeRx();
   HPt->PurgeTx();
   if (!HPt->SendData(Tx_Buffer,2)) return false;
   if (!HPt->ReceiveData(Rx_Buffer,1)) return false;
   if (Tx_Buffer[0] != Rx_Buffer[0]) return false;
   return true;
}
//END pagine 128 bytes

//BEGIN pagine 256 bytes
DataStreamPage256byte::DataStreamPage256byte(targetdatasize_t datasize)
	: DataStream(datasize,_tps256)
{
	page256bytesNumber  = 0;
	pages = NULL;
}

DataStreamPage256byte::~DataStreamPage256byte(void)
{
	if (pages) delete [] pages;
	pages = NULL;
	page256bytesNumber  = 0;
}

bool DataStreamPage256byte::ConvFromRecordQuantum8bit(Record* RecArr,int RecArrSize,
				unsigned short numofquan,
				unsigned long* startaddr_arr,
				unsigned long* size_arr)
{
	unsigned long* startaddr_array;
	unsigned long* size_array;

	if ((numofquan < 1) || (!startaddr_arr) || (!size_arr)) throw ("DataStream: Error in constructor parameter definition");
	numofquantum = numofquan;
	startaddr_array = new unsigned long [numofquantum];
	if (!startaddr_array) throw ("DataStream: startaddr_array : Error in constructor parameter allocation");
	size_array = new unsigned long [numofquantum];
	if (!size_array) throw ("DataStream: size_array : Error in constructor parameter allocation");
	for (unsigned short i = 0; i < numofquantum; i++) {
		startaddr_array[i] = startaddr_arr[i];
		size_array[i] = size_arr[i];
		page256bytesNumber +=  (size_array[i] / PAGESIZE256);
		}
	Block8bit = NULL;
//   page256bytesNumber  = PAGESNUMBER;
	switch (targetdatasize) {
		case _8bit:
			Block8bit = new quantum8bit_t*[numofquantum];
			if (!Block8bit) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
				for (unsigned short i = 0; i < numofquantum; i++) {
					Block8bit[i] = new quantum8bit_t();
					if (!Block8bit[i]) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
					Block8bit[i]->BaseAddr = startaddr_array[i];
					Block8bit[i]->Size = size_array[i];
					Block8bit[i]->Data = new unsigned char[Block8bit[i]->Size];
					if (!Block8bit[i]->Data) throw ("DataStream: Block8bit : Error in constructor parameter allocation");
					Block8bit[i]->ptr = 0;
					for (unsigned long j = 0; j < Block8bit[i]->Size; j++)  Block8bit[i]->Data[j] = 0xFF;
					}
				break;
		default : break;
		}
	if (startaddr_array) delete [] startaddr_array;
	if (size_array) delete [] size_array;


	unsigned long Off = 0 ;
	unsigned long BAddr = 0;
	RecordArricchito* RecL = new  RecordArricchito();
	if (!RecL) throw ("DataStream: RecL : Error in constructor parameter allocation");
	for (int i = 0; i < RecArrSize; i++) {
		(*((Record*)RecL)) = RecArr[i];
		BAddr = RecL->GetBaseAddr();
		for (unsigned short v = 0; v < numofquantum; v++) {
			if ((BAddr >= Block8bit[v]->BaseAddr) && (((double)BAddr) < (((double)(Block8bit[v]->BaseAddr)) + Block8bit[v]->Size))) {
				Off = BAddr - Block8bit[v]->BaseAddr;
				if ((Off > Block8bit[v]->Size) || (RecL->GetTipo() != DATA)) continue;
				for (int j = 0; j <  RecL->GetNumOfData(); j++)
					if ((Off + j) <= Block8bit[v]->Size) {
						Block8bit[v]->Data[Off + j] = RecL->GetData((unsigned char)j);
						Block8bit[v]->ptr = Off + j;
						}
				Block8bit[v]->ptr++;
				break;
				}
			}
		}
	unsigned long acc = 0;//Block8bit[0]->BaseAddr;
	pages = new page256bytes[page256bytesNumber];
	if (!pages) throw ("DataStream: pages : Error in constructor parameter allocation");
	for (unsigned long i = 0; i < page256bytesNumber;) {
		pages[i].Addr = acc;
		for (unsigned short v = 0; v < numofquantum; v++) {
			if ((pages[i].Addr >= Block8bit[v]->BaseAddr) && (((double)(pages[i].Addr)) < (((double)(Block8bit[v]->BaseAddr)) + Block8bit[v]->Size))) { // somma maggiore di 0xffffffff
				for (int j = 0; j < PAGESIZE256; j++) pages[i].Data[j] = Block8bit[v]->Data[acc - Block8bit[v]->BaseAddr + j];
				acc += PAGESIZE256;
				i++;
				break;
				}
			else if (pages[i].Addr < Block8bit[v]->BaseAddr)
				acc = Block8bit[v]->BaseAddr;
			}
		}
	delete RecL;
	return true;
}

bool DataStreamPage256byte::IsDummyPage(unsigned long Num)
{
	for (int i = 0; i < PAGESIZE256; i++) if (pages[Num].Data[i] != 0xFF) return false;
	return true;
}

bool DataStreamPage256byte::SendPage(arnSerialInterface *HPt,unsigned long Num)
{
	pages[Num].ntwrite = 0;
	if (IsDummyPage(Num)) return true;

	char Tx_Buffer[512],Rx_Buffer[64];

	Tx_Buffer[0] = (char) ('P');
	Tx_Buffer[1] = (char) ((unsigned char) (PAGESIZE256 + 5));
	HPt->PurgeRx();
	HPt->PurgeTx();
	if (!HPt->SendData(Tx_Buffer,2)) {
		return false;
		}

	if (!HPt->ReceiveData(Rx_Buffer,1)) {
		return false;
		}
	if (Rx_Buffer[0] != 'K') {
		return false;
		}

	Tx_Buffer[2] = (char) ((pages[Num].Addr & 0xFF000000) >> 24);
	Tx_Buffer[3] = (char) ((pages[Num].Addr & 0x00FF0000) >> 16);
	Tx_Buffer[4] = (char) ((pages[Num].Addr & 0x0000FF00) >> 8);
	Tx_Buffer[5] = (char) ((pages[Num].Addr & 0x000000FF));
//	test test test
//	if (pages[Num].Addr ==0x00410000) {
//		unsigned char ppp= 0;
//		ppp++;
//		}

	for (int i = 0; i < PAGESIZE256; i++) Tx_Buffer[6 + i] = (char) (pages[Num].Data[i]);

	Tx_Buffer[6 + PAGESIZE256] = 0;
	for (unsigned short count = 0; count < (PAGESIZE256 + 6); count++) Tx_Buffer[6 + PAGESIZE256] += Tx_Buffer[count];

	HPt->PurgeRx();
	HPt->PurgeTx();
	if (!HPt->SendData((Tx_Buffer + 2),(PAGESIZE256 + 5))) {
		return false;
		}
	Rx_Buffer[0] = 0;
	unsigned char cntt = 3;
	while((Rx_Buffer[0] != ((char)ADDROUTOFRANGE)) &&
		(Rx_Buffer[0] != ((char)PRGNOTPAGE)) &&
		(Rx_Buffer[0] != ((char)PRGOKPAGE)) &&
		(Rx_Buffer[0] != 'C') &&
		(cntt)
		) {
		if (HPt->ReceiveData(Rx_Buffer,1)) {
		/*if ((Rx_Buffer[0] != ((char)PRGNOTPAGE)) &&
			(Rx_Buffer[0] != ((char)PRGOKPAGE))&&
			(Rx_Buffer[0] != 'C') &&
			(Rx_Buffer[0] != ((char)ADDROUTOFRANGE))
			) pages[Num].ntwrite = Rx_Buffer[0];
		*/
			if (Rx_Buffer[0] == 'N') {
				if (HPt->ReceiveData(Rx_Buffer + 1,1)) {
					if (Rx_Buffer[1] == 'T') {
						if (HPt->ReceiveData(Rx_Buffer + 2,1)) {
							pages[Num].ntwrite = Rx_Buffer[2];
							}
						}
					}
				}
			}
		else cntt--;
		}
	if ((!cntt) || (Rx_Buffer[0] == 'C') || (((unsigned char) Rx_Buffer[0]) == PRGNOTPAGE)) {
		return false;
		}
	else if (((unsigned char) Rx_Buffer[0]) == ADDROUTOFRANGE) {
		HPt->ReceiveData(Rx_Buffer + 1,4);
		return false;
		}
	return true;
}


bool DataStreamPage256byte::SendEndSignal(arnSerialInterface *HPt)
{
   char Tx_Buffer[2],Rx_Buffer[2];
   // ******** record finale E0xFF
   Tx_Buffer[0] = (char) ('E');
   Tx_Buffer[1] = (char) (0xFF);

   HPt->PurgeRx();
   HPt->PurgeTx();
   if (!HPt->SendData(Tx_Buffer,2)) return false;
   if (!HPt->ReceiveData(Rx_Buffer,1)) return false;
   if (Tx_Buffer[0] != Rx_Buffer[0]) return false;
   return true;
}
//END pagine 256 bytes
